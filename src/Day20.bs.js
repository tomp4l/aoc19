// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Relude_Set = require("relude/src/Relude_Set.bs.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");
var Relude_List_Specializations = require("relude/src/list/Relude_List_Specializations.bs.js");

var SquareWithNeighbours = {};

function compare(param, param$1) {
  var s = Curry._2(Relude_String.Ord.compare, param[0], param$1[0]);
  if (s === "equal_to") {
    return Coord$Aoc19.CoordOrd.compare(param[1], param$1[1]);
  } else {
    return s;
  }
}

function eq(a, b) {
  return compare(a, b) === "equal_to";
}

var Ord = {
  eq: eq,
  compare: compare
};

var $$Set = Relude_Set.WithOrd(Ord);

var StringWithCoords = {
  Ord: Ord,
  $$Set: $$Set
};

function isPortal(c) {
  switch (c) {
    case " " :
    case "#" :
    case "." :
        return false;
    default:
      return true;
  }
}

function findPortals(charMap) {
  var _c = [
    0,
    0
  ];
  var _portals = $$Set.empty;
  while(true) {
    var portals = _portals;
    var c = _c;
    var y = c[1];
    var x = c[0];
    var c$1 = Curry._2(Coord$Aoc19.CoordMap.get, c, charMap);
    if (c$1 !== undefined) {
      if (isPortal(c$1)) {
        var right_0 = x + 1 | 0;
        var right = [
          right_0,
          y
        ];
        var down_1 = y + 1 | 0;
        var down = [
          x,
          down_1
        ];
        var match = Curry._2(Coord$Aoc19.CoordMap.get, right, charMap);
        var match$1 = Curry._2(Coord$Aoc19.CoordMap.get, down, charMap);
        var exit = 0;
        if (match !== undefined) {
          if (isPortal(match)) {
            var match$2 = Curry._2(Coord$Aoc19.CoordMap.get, [
                  x + 2 | 0,
                  y
                ], charMap);
            var coord = match$2 === "." ? [
                x + 2 | 0,
                y
              ] : [
                x - 1 | 0,
                y
              ];
            _portals = Curry._2($$Set.add, [
                  c$1 + match,
                  coord
                ], portals);
            _c = [
              x + 1 | 0,
              y
            ];
            continue ;
          }
          exit = 2;
        } else {
          exit = 2;
        }
        if (exit === 2 && match$1 !== undefined && isPortal(match$1)) {
          var match$3 = Curry._2(Coord$Aoc19.CoordMap.get, [
                x,
                y + 2 | 0
              ], charMap);
          var coord$1 = match$3 === "." ? [
              x,
              y + 2 | 0
            ] : [
              x,
              y - 1 | 0
            ];
          _portals = Curry._2($$Set.add, [
                c$1 + match$1,
                coord$1
              ], portals);
          _c = [
            x + 1 | 0,
            y
          ];
          continue ;
        }
        _c = [
          x + 1 | 0,
          y
        ];
        continue ;
      }
      _c = [
        x + 1 | 0,
        y
      ];
      continue ;
    }
    if (x === 0) {
      return portals;
    }
    _c = [
      0,
      y + 1 | 0
    ];
    continue ;
  };
}

function createMap(width, height, charMap) {
  var portals = findPortals(charMap);
  var loopMapWithPortals = function (_param, _remaining, _map) {
    while(true) {
      var param = _param;
      var map = _map;
      var remaining = _remaining;
      var previousCoord = param[1];
      var p = Curry._1($$Set.minimum, remaining);
      if (p === undefined) {
        return map;
      }
      var c = p[1];
      var y = c[1];
      var x = c[0];
      var outer = Relude_Option.getOrThrow(Curry._1(Relude_List_Specializations.Int.min, {
                hd: x,
                tl: {
                  hd: y,
                  tl: {
                    hd: width - x | 0,
                    tl: {
                      hd: height - y | 0,
                      tl: /* [] */0
                    }
                  }
                }
              })) < 5;
      var next = p[0] === param[0] ? Curry._3(Coord$Aoc19.CoordMap.set, c, {
              square: outer ? /* OuterPortal */4 : /* InnerPortal */3,
              neighbours: {
                hd: previousCoord,
                tl: /* [] */0
              }
            }, Curry._3(Coord$Aoc19.CoordMap.set, previousCoord, {
                  square: outer ? /* InnerPortal */3 : /* OuterPortal */4,
                  neighbours: {
                    hd: c,
                    tl: /* [] */0
                  }
                }, map)) : map;
      _map = next;
      _remaining = Curry._2($$Set.remove, p, remaining);
      _param = p;
      continue ;
    };
  };
  var addCoordinateIfExists = function (param, points) {
    var y = param[1];
    var x = param[0];
    var match = Curry._2(Coord$Aoc19.CoordMap.get, [
          x,
          y
        ], charMap);
    if (match === ".") {
      return {
              square: points.square,
              neighbours: {
                hd: [
                  x,
                  y
                ],
                tl: points.neighbours
              }
            };
    } else {
      return points;
    }
  };
  var match = Curry._1($$Set.minimum, portals);
  var match$1 = Curry._1($$Set.maximum, portals);
  var startMap;
  if (match !== undefined && match[0] === "AA" && match$1 !== undefined) {
    var min = match[1];
    startMap = match$1[0] === "ZZ" ? loopMapWithPortals([
            "AA",
            min
          ], Curry._2($$Set.remove, [
                "AA",
                min
              ], portals), Curry._3(Coord$Aoc19.CoordMap.set, match$1[1], {
                square: /* End */1,
                neighbours: /* [] */0
              }, Curry._3(Coord$Aoc19.CoordMap.set, min, {
                    square: /* Start */0,
                    neighbours: /* [] */0
                  }, Curry._1(Coord$Aoc19.CoordMap.make, undefined)))) : Curry._1(Coord$Aoc19.CoordMap.make, undefined);
  } else {
    startMap = Curry._1(Coord$Aoc19.CoordMap.make, undefined);
  }
  var _c = [
    0,
    0
  ];
  var _map = startMap;
  while(true) {
    var map = _map;
    var c = _c;
    var y = c[1];
    var x = c[0];
    var match$2 = Curry._2(Coord$Aoc19.CoordMap.get, c, charMap);
    if (match$2 !== undefined) {
      if (match$2 === ".") {
        var points = addCoordinateIfExists([
              x,
              y - 1 | 0
            ], addCoordinateIfExists([
                  x,
                  y + 1 | 0
                ], addCoordinateIfExists([
                      x - 1 | 0,
                      y
                    ], addCoordinateIfExists([
                          x + 1 | 0,
                          y
                        ], Relude_Option.getOrElse({
                              square: /* Floor */2,
                              neighbours: /* [] */0
                            }, Curry._2(Coord$Aoc19.CoordMap.get, c, map))))));
        _map = Curry._3(Coord$Aoc19.CoordMap.set, c, points, map);
        _c = [
          x + 1 | 0,
          y
        ];
        continue ;
      }
      _c = [
        x + 1 | 0,
        y
      ];
      continue ;
    }
    if (x === 0) {
      return map;
    }
    _c = [
      0,
      y + 1 | 0
    ];
    continue ;
  };
}

function fromString(s) {
  var split = Relude_List.map(function (param) {
          return Relude_String.splitAsList("", param);
        })(Relude_String.splitAsList("\n", s));
  var width = Relude_Option.getOrElse(0, Relude_Option.map(Relude_List.length, Relude_List.head(split)));
  var height = Curry._1(Relude_List.length, split);
  return createMap(width, height, Curry._1(Coord$Aoc19.CoordMap.fromList, Coord$Aoc19.addCoordinates(split)));
}

function getStart(map) {
  return Relude_Option.getOrThrow(Curry._2(Coord$Aoc19.CoordMap.find, (function (param, param$1) {
                      return param$1.square === /* Start */0;
                    }), map))[0];
}

function traverse(map) {
  var _visited = Coord$Aoc19.CoordSet.empty;
  var _remaining = {
    hd: [
      getStart(map),
      0
    ],
    tl: /* [] */0
  };
  while(true) {
    var remaining = _remaining;
    var visited = _visited;
    if (!remaining) {
      return -1;
    }
    var others = remaining.tl;
    var match = remaining.hd;
    var distance = match[1];
    var next = match[0];
    var match$1 = Curry._2(Coord$Aoc19.CoordMap.get, next, map);
    if (Curry._2(Coord$Aoc19.CoordSet.contains, next, visited)) {
      _remaining = others;
      continue ;
    }
    if (match$1 !== undefined) {
      if (match$1.square === 1) {
        return distance;
      }
      _remaining = Relude_List.concat(others, Relude_List.map((function(distance){
                return function (n) {
                  return [
                          n,
                          distance + 1 | 0
                        ];
                }
                }(distance)))(match$1.neighbours));
      _visited = Curry._2(Coord$Aoc19.CoordSet.add, next, visited);
      continue ;
    }
    _remaining = others;
    _visited = Curry._2(Coord$Aoc19.CoordSet.add, next, visited);
    continue ;
  };
}

function traverseRecursive(map) {
  var _visitedPerLevel = Curry._1(Relude_Int.$$Map.make, undefined);
  var _remaining = {
    hd: [
      getStart(map),
      0,
      1
    ],
    tl: /* [] */0
  };
  while(true) {
    var remaining = _remaining;
    var visitedPerLevel = _visitedPerLevel;
    if (!remaining) {
      return -1;
    }
    var others = remaining.tl;
    var match = remaining.hd;
    var level = match[2];
    var distance = match[1];
    var next = match[0];
    var visited = Curry._3(Relude_Int.$$Map.getOrElse, level, Coord$Aoc19.CoordSet.empty, visitedPerLevel);
    var addedToVisitedPerLevel = Curry._3(Relude_Int.$$Map.set, level, Curry._2(Coord$Aoc19.CoordSet.add, next, visited), visitedPerLevel);
    var match$1 = Curry._2(Coord$Aoc19.CoordMap.get, next, map);
    if (Curry._2(Coord$Aoc19.CoordSet.contains, next, visited)) {
      _remaining = others;
      continue ;
    }
    if (match$1 !== undefined) {
      var square = match$1.square;
      if (square !== 1) {
        if (square >= 4 && level === 1) {
          _remaining = others;
          _visitedPerLevel = addedToVisitedPerLevel;
          continue ;
        }
        
      } else if (level === 1) {
        return distance;
      }
      var isHop = function (param, param$1) {
        return (Curry._1(Relude_Int.abs, param[0] - param$1[0] | 0) + Curry._1(Relude_Int.abs, param[1] - param$1[1] | 0) | 0) > 1;
      };
      var newNeighbors = Relude_List.map((function(next,distance,level,square){
            return function (n) {
              return [
                      n,
                      distance + 1 | 0,
                      square !== 3 ? (
                          square >= 4 && isHop(next, n) ? level - 1 | 0 : level
                        ) : (
                          isHop(next, n) ? level + 1 | 0 : level
                        )
                    ];
            }
            }(next,distance,level,square)))(match$1.neighbours);
      _remaining = Relude_List.concat(others, newNeighbors);
      _visitedPerLevel = addedToVisitedPerLevel;
      continue ;
    }
    _remaining = others;
    _visitedPerLevel = addedToVisitedPerLevel;
    continue ;
  };
}

var Maze = {
  isPortal: isPortal,
  findPortals: findPortals,
  createMap: createMap,
  fromString: fromString,
  getStart: getStart,
  traverse: traverse,
  traverseRecursive: traverseRecursive
};

var input = InputLoader$Aoc19.loadDay(20);

StackSafeFuture$Aoc19.tap(function (s) {
        console.log(traverse(fromString(s)));
        
      })(input);

StackSafeFuture$Aoc19.tap(function (s) {
        console.log(traverseRecursive(fromString(s)));
        
      })(input);

exports.SquareWithNeighbours = SquareWithNeighbours;
exports.StringWithCoords = StringWithCoords;
exports.Maze = Maze;
exports.input = input;
/* Set Not a pure module */
