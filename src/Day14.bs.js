// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var Relude_StringMap = require("relude/src/Relude_StringMap.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

var ParseError = Caml_exceptions.create("Day14-Aoc19.Factory.ParseError");

function parseItem(item) {
  var match = Relude_String.splitList(" ", item);
  if (match) {
    var match$1 = match[1];
    if (match$1) {
      if (match$1[1]) {
        throw [
              ParseError,
              item
            ];
      }
      return /* record */[
              /* amount */Caml_format.caml_int_of_string(match[0]),
              /* chemical */match$1[0]
            ];
    } else {
      throw [
            ParseError,
            item
          ];
    }
  } else {
    throw [
          ParseError,
          item
        ];
  }
}

function parseInputLine(line) {
  var ingredientProduct = Relude_String.splitList(" => ", line);
  if (ingredientProduct) {
    var match = ingredientProduct[1];
    if (match) {
      if (match[1]) {
        throw [
              ParseError,
              line
            ];
      }
      var splitIngredients = Relude_String.splitList(", ", ingredientProduct[0]);
      var ingredients = Relude_List.map(parseItem)(splitIngredients);
      var match$1 = parseItem(match[0]);
      var recipe_000 = /* amountMade */match$1[/* amount */0];
      var recipe = /* record */[
        recipe_000,
        /* ingredients */ingredients
      ];
      return /* tuple */[
              match$1[/* chemical */1],
              recipe
            ];
    } else {
      throw [
            ParseError,
            line
          ];
    }
  } else {
    throw [
          ParseError,
          line
        ];
  }
}

function parseInputLines(lines) {
  return Curry._1(Relude_StringMap.fromList, Relude_List.map(parseInputLine)(lines));
}

function getRecipe(recipeList, item) {
  return Relude_Option.getOrThrow(Curry._2(Relude_StringMap.get, item, recipeList));
}

function findOreCost(amount, item, recipeList) {
  var loop = function (amountNeeded, ingredients, leftOvers) {
    if (ingredients) {
      var match = ingredients[0];
      var chemical = match[/* chemical */1];
      var amount = match[/* amount */0];
      if (chemical === "ORE") {
        var match$1 = loop(amountNeeded, ingredients[1], leftOvers);
        return /* tuple */[
                Caml_int64.add(Caml_int64.mul(Caml_int64.of_int32(amount), amountNeeded), match$1[0]),
                match$1[1]
              ];
      } else {
        var amount$1 = Caml_int64.mul(Caml_int64.of_int32(amount), amountNeeded);
        var match$2 = Relude_Option.getOrThrow(Curry._2(Relude_StringMap.get, chemical, recipeList));
        var amountMade = Caml_int64.of_int32(match$2[/* amountMade */0]);
        var leftOverAmount = Curry._3(Relude_StringMap.getOrElse, chemical, /* int64 */[
              /* hi */0,
              /* lo */0
            ], leftOvers);
        var match$3 = Caml_int64.ge(leftOverAmount, amount$1) ? /* tuple */[
            Caml_int64.sub(leftOverAmount, amount$1),
            /* int64 */[
              /* hi */0,
              /* lo */0
            ]
          ] : /* tuple */[
            /* int64 */[
              /* hi */0,
              /* lo */0
            ],
            Caml_int64.sub(amount$1, leftOverAmount)
          ];
        var newAmount = match$3[1];
        var requiredBatches = Caml_int64.eq(Caml_int64.mod_(newAmount, amountMade), /* int64 */[
              /* hi */0,
              /* lo */0
            ]) ? Caml_int64.div(newAmount, amountMade) : Caml_int64.add(Caml_int64.div(newAmount, amountMade), /* int64 */[
                /* hi */0,
                /* lo */1
              ]);
        var newLeftOverAmount = Caml_int64.add(match$3[0], Caml_int64.sub(Caml_int64.mul(requiredBatches, amountMade), newAmount));
        var newLeftOvers = Curry._3(Relude_StringMap.set, chemical, newLeftOverAmount, leftOvers);
        var match$4 = loop(requiredBatches, match$2[/* ingredients */1], newLeftOvers);
        var match$5 = loop(amountNeeded, ingredients[1], match$4[1]);
        return /* tuple */[
                Caml_int64.add(match$5[0], match$4[0]),
                match$5[1]
              ];
      }
    } else {
      return /* tuple */[
              /* int64 */[
                /* hi */0,
                /* lo */0
              ],
              leftOvers
            ];
    }
  };
  var match = Relude_Option.getOrThrow(Curry._2(Relude_StringMap.get, item, recipeList));
  return loop(amount, match[/* ingredients */1], Curry._1(Relude_StringMap.make, /* () */0));
}

var Factory = {
  ParseError: ParseError,
  parseItem: parseItem,
  parseInputLine: parseInputLine,
  parseInputLines: parseInputLines,
  getRecipe: getRecipe,
  findOreCost: findOreCost
};

function findFuelAmount(baseCost, recipeList) {
  var ore = Caml_format.caml_int64_of_string("1000000000000");
  var worstCase = Caml_int64.div(ore, baseCost);
  var _amount = worstCase;
  while(true) {
    var amount = _amount;
    var match = findOreCost(amount, "FUEL", recipeList);
    var cost = match[0];
    if (Caml_int64.ge(cost, ore)) {
      return Caml_int64.sub(amount, Int64.one);
    } else {
      var leftOver = Caml_int64.sub(ore, cost);
      var worstCase$1 = Caml_int64.div(leftOver, baseCost);
      if (Caml_int64.lt(worstCase$1, Int64.one)) {
        _amount = Caml_int64.add(Int64.one, amount);
        continue ;
      } else {
        _amount = Caml_int64.add(worstCase$1, amount);
        continue ;
      }
    }
  };
}

var input = InputLoader$Aoc19.newlineSeparated(14);

StackSafeFuture$Aoc19.tap((function (param) {
          return Relude_Function.flipCompose(Int64.to_string, (function (param) {
                        console.log("Fuel made", param);
                        return /* () */0;
                      }), param);
        }))(Curry._3(StackSafeFuture$Aoc19.map2, (function (i, v) {
            return findFuelAmount(v, Curry._1(Relude_StringMap.fromList, Relude_List.map(parseInputLine)(i)));
          }), input, StackSafeFuture$Aoc19.tap((function (param) {
                  return Relude_Function.flipCompose(Int64.to_string, (function (param) {
                                console.log("Ore cost", param);
                                return /* () */0;
                              }), param);
                }))(StackSafeFuture$Aoc19.map((function (i) {
                    return findOreCost(Int64.one, "FUEL", Curry._1(Relude_StringMap.fromList, Relude_List.map(parseInputLine)(i)))[0];
                  }), input))));

var $great$great = Relude_Function.flipCompose;

exports.$great$great = $great$great;
exports.Factory = Factory;
exports.findFuelAmount = findFuelAmount;
exports.input = input;
/* input Not a pure module */
