// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var Relude_StringMap = require("relude/src/Relude_StringMap.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

var ParseError = Caml_exceptions.create("Day14-Aoc19.Factory.ParseError");

function parseItem(item) {
  var match = Relude_String.splitList(" ", item);
  if (match) {
    var match$1 = match.tl;
    if (match$1) {
      if (match$1.tl) {
        throw {
              RE_EXN_ID: ParseError,
              _1: item,
              Error: new Error()
            };
      }
      return {
              amount: Caml_format.caml_int_of_string(match.hd),
              chemical: match$1.hd
            };
    }
    throw {
          RE_EXN_ID: ParseError,
          _1: item,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: ParseError,
        _1: item,
        Error: new Error()
      };
}

function parseInputLine(line) {
  var ingredientProduct = Relude_String.splitList(" => ", line);
  if (ingredientProduct) {
    var match = ingredientProduct.tl;
    if (match) {
      if (match.tl) {
        throw {
              RE_EXN_ID: ParseError,
              _1: line,
              Error: new Error()
            };
      }
      var splitIngredients = Relude_String.splitList(", ", ingredientProduct.hd);
      var ingredients = Relude_List.map(parseItem)(splitIngredients);
      var match$1 = parseItem(match.hd);
      var recipe_amountMade = match$1.amount;
      var recipe = {
        amountMade: recipe_amountMade,
        ingredients: ingredients
      };
      return [
              match$1.chemical,
              recipe
            ];
    }
    throw {
          RE_EXN_ID: ParseError,
          _1: line,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: ParseError,
        _1: line,
        Error: new Error()
      };
}

function parseInputLines(lines) {
  return Curry._1(Relude_StringMap.fromList, Relude_List.map(parseInputLine)(lines));
}

function getRecipe(recipeList, item) {
  return Relude_Option.getOrThrow(Curry._2(Relude_StringMap.get, item, recipeList));
}

function findOreCost(amount, item, recipeList) {
  var loop = function (amountNeeded, ingredients, leftOvers) {
    if (!ingredients) {
      return [
              Caml_int64.zero,
              leftOvers
            ];
    }
    var match = ingredients.hd;
    var chemical = match.chemical;
    var amount = match.amount;
    if (chemical === "ORE") {
      var match$1 = loop(amountNeeded, ingredients.tl, leftOvers);
      return [
              Caml_int64.add(Caml_int64.mul(Caml_int64.of_int32(amount), amountNeeded), match$1[0]),
              match$1[1]
            ];
    }
    var amount$1 = Caml_int64.mul(Caml_int64.of_int32(amount), amountNeeded);
    var match$2 = Relude_Option.getOrThrow(Curry._2(Relude_StringMap.get, chemical, recipeList));
    var amountMade = Caml_int64.of_int32(match$2.amountMade);
    var leftOverAmount = Curry._3(Relude_StringMap.getOrElse, chemical, Caml_int64.zero, leftOvers);
    var match$3 = Caml_int64.ge(leftOverAmount, amount$1) ? [
        Caml_int64.sub(leftOverAmount, amount$1),
        Caml_int64.zero
      ] : [
        Caml_int64.zero,
        Caml_int64.sub(amount$1, leftOverAmount)
      ];
    var newAmount = match$3[1];
    var requiredBatches = Caml_int64.eq(Caml_int64.mod_(newAmount, amountMade), Caml_int64.zero) ? Caml_int64.div(newAmount, amountMade) : Caml_int64.add(Caml_int64.div(newAmount, amountMade), Caml_int64.one);
    var newLeftOverAmount = Caml_int64.add(match$3[0], Caml_int64.sub(Caml_int64.mul(requiredBatches, amountMade), newAmount));
    var newLeftOvers = Curry._3(Relude_StringMap.set, chemical, newLeftOverAmount, leftOvers);
    var match$4 = loop(requiredBatches, match$2.ingredients, newLeftOvers);
    var match$5 = loop(amountNeeded, ingredients.tl, match$4[1]);
    return [
            Caml_int64.add(match$5[0], match$4[0]),
            match$5[1]
          ];
  };
  var match = Relude_Option.getOrThrow(Curry._2(Relude_StringMap.get, item, recipeList));
  return loop(amount, match.ingredients, Curry._1(Relude_StringMap.make, undefined));
}

var Factory = {
  ParseError: ParseError,
  parseItem: parseItem,
  parseInputLine: parseInputLine,
  parseInputLines: parseInputLines,
  getRecipe: getRecipe,
  findOreCost: findOreCost
};

function findFuelAmount(baseCost, recipeList) {
  var ore = Caml_format.caml_int64_of_string("1000000000000");
  var worstCase = Caml_int64.div(ore, baseCost);
  var _amount = worstCase;
  while(true) {
    var amount = _amount;
    var match = findOreCost(amount, "FUEL", recipeList);
    var cost = match[0];
    if (Caml_int64.ge(cost, ore)) {
      return Caml_int64.sub(amount, Int64.one);
    }
    var leftOver = Caml_int64.sub(ore, cost);
    var worstCase$1 = Caml_int64.div(leftOver, baseCost);
    if (Caml_int64.lt(worstCase$1, Int64.one)) {
      _amount = Caml_int64.add(Int64.one, amount);
      continue ;
    }
    _amount = Caml_int64.add(worstCase$1, amount);
    continue ;
  };
}

var input = InputLoader$Aoc19.newlineSeparated(14);

StackSafeFuture$Aoc19.tap(function (param) {
        return Relude_Function.flipCompose(Int64.to_string, (function (param) {
                      console.log("Fuel made", param);
                      
                    }), param);
      })(Curry._3(StackSafeFuture$Aoc19.map2, (function (i, v) {
            return findFuelAmount(v, Curry._1(Relude_StringMap.fromList, Relude_List.map(parseInputLine)(i)));
          }), input, StackSafeFuture$Aoc19.tap(function (param) {
                return Relude_Function.flipCompose(Int64.to_string, (function (param) {
                              console.log("Ore cost", param);
                              
                            }), param);
              })(StackSafeFuture$Aoc19.map((function (i) {
                    return findOreCost(Int64.one, "FUEL", Curry._1(Relude_StringMap.fromList, Relude_List.map(parseInputLine)(i)))[0];
                  }), input))));

var $great$great = Relude_Function.flipCompose;

exports.$great$great = $great$great;
exports.Factory = Factory;
exports.findFuelAmount = findFuelAmount;
exports.input = input;
/* input Not a pure module */
