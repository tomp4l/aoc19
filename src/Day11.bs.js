// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Intcode$Aoc19 = require("./Intcode.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

function rotate(d, r) {
  switch (d) {
    case /* Up */0 :
        if (r) {
          return /* Left */2;
        } else {
          return /* Right */3;
        }
    case /* Down */1 :
        if (r) {
          return /* Right */3;
        } else {
          return /* Left */2;
        }
    case /* Left */2 :
        if (r) {
          return /* Down */1;
        } else {
          return /* Up */0;
        }
    case /* Right */3 :
        if (r) {
          return /* Up */0;
        } else {
          return /* Down */1;
        }
    
  }
}

function move(param, d) {
  var match;
  switch (d) {
    case /* Up */0 :
        match = /* tuple */[
          0,
          -1
        ];
        break;
    case /* Down */1 :
        match = /* tuple */[
          0,
          1
        ];
        break;
    case /* Left */2 :
        match = /* tuple */[
          -1,
          0
        ];
        break;
    case /* Right */3 :
        match = /* tuple */[
          1,
          0
        ];
        break;
    
  }
  return /* tuple */[
          param[0] + match[0] | 0,
          param[1] + match[1] | 0
        ];
}

function colorToInt(c) {
  if (c) {
    return 0;
  } else {
    return 1;
  }
}

function colorToDisplay(c) {
  if (c) {
    return " ";
  } else {
    return "#";
  }
}

var UnknownInput = Caml_exceptions.create("Day11-Aoc19.UnknownInput");

function intToColor(i) {
  if (i !== 0) {
    if (i !== 1) {
      throw [
            UnknownInput,
            i
          ];
    } else {
      return /* White */0;
    }
  } else {
    return /* Black */1;
  }
}

function intToRotation(i) {
  if (i !== 0) {
    if (i !== 1) {
      throw [
            UnknownInput,
            i
          ];
    } else {
      return /* Clockwise */0;
    }
  } else {
    return /* Anticlockwise */1;
  }
}

function get(c) {
  var partial_arg = Curry._1(Coord$Aoc19.CoordMap.get, c);
  return (function (param) {
      return Relude_Function.flipCompose(partial_arg, (function (param) {
                    return Relude_Option.getOrElse(/* Black */1, param);
                  }), param);
    });
}

var paint = Coord$Aoc19.CoordMap.set;

function make(c) {
  return Curry._3(paint, /* tuple */[
              0,
              0
            ], c, Curry._1(Coord$Aoc19.CoordMap.make, /* () */0));
}

var partial_arg = Coord$Aoc19.CoordMap.keys;

function totalPainted(param) {
  return Relude_Function.flipCompose(partial_arg, Relude_List.length, param);
}

function drawShip(param) {
  return Coord$Aoc19.output(colorToDisplay, /* Black */1, param);
}

var Ship = {
  get: get,
  paint: paint,
  make: make,
  totalPainted: totalPainted,
  drawShip: drawShip
};

var initial = /* record */[
  /* position : tuple */[
    0,
    0
  ],
  /* direction : Up */0,
  /* isPainting */true
];

function doPaint(color, robot, ship) {
  return /* tuple */[
          Curry._3(paint, robot[/* position */0], color, ship),
          /* record */[
            /* position */robot[/* position */0],
            /* direction */robot[/* direction */1],
            /* isPainting */false
          ]
        ];
}

function doRotateAndMove(rotation, robot) {
  var nextDirection = rotate(robot[/* direction */1], rotation);
  var nextPosition = move(robot[/* position */0], nextDirection);
  return /* record */[
          /* position */nextPosition,
          /* direction */nextDirection,
          /* isPainting */true
        ];
}

function paintShip(start, input) {
  var robot = /* record */[/* contents */initial];
  var ship = /* record */[/* contents */make(start)];
  var nextInput = function (param) {
    var match = robot[0];
    var c = get(match[/* position */0])(ship[0]);
    return StackSafeFuture$Aoc19.pure(String(c ? 0 : 1));
  };
  var nextOutput = function (string) {
    var v = Caml_format.caml_int_of_string(string);
    var match = robot[0];
    var match$1 = match[/* isPainting */2] ? doPaint(intToColor(v), robot[0], ship[0]) : /* tuple */[
        ship[0],
        doRotateAndMove(intToRotation(v), robot[0])
      ];
    ship[0] = match$1[0];
    robot[0] = match$1[1];
    return /* () */0;
  };
  return StackSafeFuture$Aoc19.map((function (param) {
                return ship[0];
              }), Intcode$Aoc19.run(nextInput, nextOutput, input));
}

var Robot = {
  initial: initial,
  doPaint: doPaint,
  doRotateAndMove: doRotateAndMove,
  paintShip: paintShip
};

var input = InputLoader$Aoc19.commaSeparated(11);

StackSafeFuture$Aoc19.tap(drawShip)(StackSafeFuture$Aoc19.tap((function (param) {
              console.log("Proper job:");
              return /* () */0;
            }))(Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                return paintShip(/* White */0, param);
              }), Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                    return input;
                  }), StackSafeFuture$Aoc19.tap((function (param) {
                          return Relude_Function.flipCompose(totalPainted, (function (param) {
                                        console.log("Total painted", param);
                                        return /* () */0;
                                      }), param);
                        }))(Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                            return paintShip(/* Black */1, param);
                          }), input))))));

var CoordMap = 0;

var $great$great = Relude_Function.flipCompose;

exports.CoordMap = CoordMap;
exports.$great$great = $great$great;
exports.rotate = rotate;
exports.move = move;
exports.colorToInt = colorToInt;
exports.colorToDisplay = colorToDisplay;
exports.UnknownInput = UnknownInput;
exports.intToColor = intToColor;
exports.intToRotation = intToRotation;
exports.Ship = Ship;
exports.Robot = Robot;
exports.input = input;
/* input Not a pure module */
