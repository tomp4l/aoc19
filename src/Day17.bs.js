// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Char = require("bs-platform/lib/js/char.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Intcode$Aoc19 = require("./Intcode.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");
var Relude_List_Specializations = require("relude/src/list/Relude_List_Specializations.bs.js");

function spriteToDisplay(param) {
  switch (param) {
    case /* Empty */0 :
        return ".";
    case /* Scaffold */1 :
        return "#";
    case /* UpRobot */2 :
        return "^";
    case /* DownRobot */3 :
        return "v";
    case /* LeftRobot */4 :
        return "<";
    case /* RightRobot */5 :
        return ">";
    case /* FuckedRobot */6 :
        return "X";
    
  }
}

var draw = Coord$Aoc19.CoordMap.set;

var make = Coord$Aoc19.CoordMap.make;

function get(c, s) {
  return Curry._3(Coord$Aoc19.CoordMap.getOrElse, c, /* Empty */0, s);
}

var getCoords = Coord$Aoc19.CoordMap.keys;

function findUpRobot(screen) {
  return Relude_Option.getOrThrow(Relude_List.head(Curry._1(Coord$Aoc19.CoordMap.keys, Curry._2(Coord$Aoc19.CoordMap.filter, (function (param, v) {
                            return v === /* UpRobot */2;
                          }), screen))));
}

function output(param) {
  return Coord$Aoc19.output(spriteToDisplay, /* Empty */0, param);
}

var $$Screen = {
  draw: draw,
  make: make,
  get: get,
  getCoords: getCoords,
  findUpRobot: findUpRobot,
  output: output
};

var InvalidCodePoint = Caml_exceptions.create("Day17-Aoc19.Camera.InvalidCodePoint");

function takeImage(input) {
  var position = {
    contents: /* tuple */[
      0,
      0
    ]
  };
  var screen = {
    contents: Curry._1(make, /* () */0)
  };
  var nextOutput = function (string) {
    var v = Caml_format.caml_int_of_string(string);
    var match = position.contents;
    var y = match[1];
    var nextSprite;
    if (v >= 60) {
      if (v >= 94) {
        if (v !== 118) {
          if (v >= 95) {
            throw [
                  InvalidCodePoint,
                  v
                ];
          } else {
            nextSprite = /* UpRobot */2;
          }
        } else {
          nextSprite = /* DownRobot */3;
        }
      } else if (v !== 88) {
        if (v >= 63) {
          throw [
                InvalidCodePoint,
                v
              ];
        }
        switch (v - 60 | 0) {
          case 0 :
              nextSprite = /* LeftRobot */4;
              break;
          case 1 :
              throw [
                    InvalidCodePoint,
                    v
                  ];
          case 2 :
              nextSprite = /* RightRobot */5;
              break;
          
        }
      } else {
        nextSprite = /* FuckedRobot */6;
      }
    } else if (v !== 10) {
      if (v !== 35) {
        if (v !== 46) {
          throw [
                InvalidCodePoint,
                v
              ];
        } else {
          nextSprite = /* Empty */0;
        }
      } else {
        nextSprite = /* Scaffold */1;
      }
    } else {
      nextSprite = undefined;
    }
    if (nextSprite !== undefined) {
      screen.contents = Curry._3(draw, position.contents, nextSprite, screen.contents);
      position.contents = /* tuple */[
        match[0] + 1 | 0,
        y
      ];
      return /* () */0;
    } else {
      position.contents = /* tuple */[
        0,
        y + 1 | 0
      ];
      return /* () */0;
    }
  };
  return StackSafeFuture$Aoc19.map((function (param) {
                return screen.contents;
              }), Intcode$Aoc19.run(undefined, nextOutput, input));
}

var Camera = {
  InvalidCodePoint: InvalidCodePoint,
  takeImage: takeImage
};

var NoMoreInput = Caml_exceptions.create("Day17-Aoc19.Robot.NoMoreInput");

function run(param, input) {
  var input$1 = Relude_List.replaceAt(0, "2", input);
  var fullInput = Curry._1(Relude_List.flatten, Relude_List.intersperse(/* :: */[
            /* "\n" */10,
            /* [] */0
          ], /* :: */[
            param[0],
            /* :: */[
              param[1],
              /* :: */[
                param[2],
                /* :: */[
                  param[3],
                  /* :: */[
                    /* :: */[
                      /* "n" */110,
                      /* [] */0
                    ],
                    /* :: */[
                      /* [] */0,
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ]
          ]));
  var remainingInput = {
    contents: fullInput
  };
  var out = {
    contents: 0
  };
  var nextOutput = function (s) {
    out.contents = Caml_format.caml_int_of_string(s);
    return /* () */0;
  };
  var nextInput = function (param) {
    var match = remainingInput.contents;
    if (match) {
      remainingInput.contents = match[1];
      return StackSafeFuture$Aoc19.pure(String(match[0]));
    } else {
      throw NoMoreInput;
    }
  };
  return StackSafeFuture$Aoc19.map((function (param) {
                return out.contents;
              }), Intcode$Aoc19.run(nextInput, nextOutput, input$1));
}

var Robot = {
  NoMoreInput: NoMoreInput,
  run: run
};

function findIntersection(screen) {
  var coords = Curry._1(getCoords, screen);
  return Relude_List.filter((function (c) {
                var y = c[1];
                var x = c[0];
                if (get(c, screen) === /* Scaffold */1) {
                  var u = get(/* tuple */[
                        x,
                        y - 1 | 0
                      ], screen);
                  var d = get(/* tuple */[
                        x,
                        y + 1 | 0
                      ], screen);
                  var l = get(/* tuple */[
                        x - 1 | 0,
                        y
                      ], screen);
                  var r = get(/* tuple */[
                        x + 1 | 0,
                        y
                      ], screen);
                  if (u === /* Scaffold */1 && d === /* Scaffold */1 && l === /* Scaffold */1) {
                    return r === /* Scaffold */1;
                  } else {
                    return false;
                  }
                } else {
                  return false;
                }
              }), coords);
}

var partial_arg = Relude_List.map((function (param) {
        return Caml_int32.imul(param[0], param[1]);
      }));

function intersectionsToAlignmentParameters(param) {
  return Relude_Function.flipCompose(partial_arg, Relude_List_Specializations.Int.sum, param);
}

function nextPosition(param, param$1) {
  var y = param[1];
  var x = param[0];
  switch (param$1) {
    case /* Up */0 :
        return /* tuple */[
                x,
                y - 1 | 0
              ];
    case /* Down */1 :
        return /* tuple */[
                x,
                y + 1 | 0
              ];
    case /* Left */2 :
        return /* tuple */[
                x - 1 | 0,
                y
              ];
    case /* Right */3 :
        return /* tuple */[
                x + 1 | 0,
                y
              ];
    
  }
}

function leftRight(param) {
  switch (param) {
    case /* Up */0 :
        return /* tuple */[
                /* Left */2,
                /* Right */3
              ];
    case /* Down */1 :
        return /* tuple */[
                /* Right */3,
                /* Left */2
              ];
    case /* Left */2 :
        return /* tuple */[
                /* Down */1,
                /* Up */0
              ];
    case /* Right */3 :
        return /* tuple */[
                /* Up */0,
                /* Down */1
              ];
    
  }
}

var InvalidState = Caml_exceptions.create("Day17-Aoc19.InvalidState");

function findPath(screen) {
  var start = findUpRobot(screen);
  var _pos = start;
  var _direction = /* Up */0;
  var _instructions = /* [] */0;
  while(true) {
    var instructions = _instructions;
    var direction = _direction;
    var pos = _pos;
    var np = nextPosition(pos, direction);
    var match = leftRight(direction);
    var r = match[1];
    var l = match[0];
    var lp = nextPosition(pos, l);
    var rp = nextPosition(pos, r);
    if (get(np, screen) === /* Scaffold */1) {
      if (instructions) {
        var match$1 = instructions[0];
        _instructions = /* :: */[
          /* tuple */[
            match$1[0],
            match$1[1] + 1 | 0
          ],
          instructions[1]
        ];
        _pos = np;
        continue ;
      } else {
        throw InvalidState;
      }
    } else if (get(lp, screen) === /* Scaffold */1) {
      _instructions = /* :: */[
        /* tuple */[
          /* LeftTurn */0,
          1
        ],
        instructions
      ];
      _direction = l;
      _pos = lp;
      continue ;
    } else if (get(rp, screen) === /* Scaffold */1) {
      _instructions = /* :: */[
        /* tuple */[
          /* RightTurn */1,
          1
        ],
        instructions
      ];
      _direction = r;
      _pos = rp;
      continue ;
    } else {
      return Relude_List.reverse(instructions);
    }
  };
}

function xToChars(render, path) {
  return Relude_List.map((function (s) {
                  return Caml_string.get(s, 0);
                }))(Curry._1(Relude_List.flatten, Relude_List.intersperse(/* :: */[
                      ",",
                      /* [] */0
                    ], Relude_List.map(render)(path))));
}

function pathToChars(param) {
  return xToChars((function (param) {
                return /* :: */[
                        param[0] ? "R" : "L",
                        /* :: */[
                          ",",
                          Relude_String.splitList("", String(param[1]))
                        ]
                      ];
              }), param);
}

var charsToAscii = Relude_List.map((function (prim) {
        return prim;
      }));

function compressedToChars(param) {
  return xToChars((function (param) {
                if (param.tag) {
                  return /* :: */[
                          Char.escaped(param[0]),
                          /* [] */0
                        ];
                } else {
                  return /* :: */[
                          param[0] ? "R" : "L",
                          /* :: */[
                            ",",
                            Relude_String.splitList("", String(param[1]))
                          ]
                        ];
                }
              }), param);
}

function replace(ident, sub, path) {
  var _subRemaining = sub;
  var _removed = /* [] */0;
  var _remaining = path;
  var _replaced = /* [] */0;
  while(true) {
    var replaced = _replaced;
    var remaining = _remaining;
    var removed = _removed;
    var subRemaining = _subRemaining;
    var exit = 0;
    if (subRemaining) {
      if (remaining) {
        var r = remaining[0];
        var match = subRemaining[0];
        if (r.tag || !(match[0] === r[0] && match[1] === r[1])) {
          exit = 2;
        } else {
          _remaining = remaining[1];
          _removed = /* :: */[
            r,
            removed
          ];
          _subRemaining = subRemaining[1];
          continue ;
        }
      } else {
        exit = 2;
      }
    } else {
      _replaced = /* :: */[
        /* Compressed */Block.__(1, [ident]),
        replaced
      ];
      _removed = /* [] */0;
      _subRemaining = sub;
      continue ;
    }
    if (exit === 2) {
      if (remaining) {
        var n = remaining[0];
        if (n.tag) {
          var replaced_001 = Relude_List.concat(removed, replaced);
          var replaced$1 = /* :: */[
            n,
            replaced_001
          ];
          _replaced = replaced$1;
          _remaining = remaining[1];
          _removed = /* [] */0;
          _subRemaining = sub;
          continue ;
        } else if (removed === /* [] */0) {
          _replaced = /* :: */[
            n,
            replaced
          ];
          _remaining = remaining[1];
          _removed = /* [] */0;
          _subRemaining = sub;
          continue ;
        }
        
      } else if (removed === /* [] */0) {
        return Relude_List.reverse(replaced);
      }
      
    }
    var replaced$2 = Relude_List.concat(removed, replaced);
    _replaced = replaced$2;
    _removed = /* [] */0;
    _subRemaining = sub;
    continue ;
  };
}

function compress(path) {
  var pathLength = Curry._1(Relude_List.length, path);
  var lengths = Relude_List.makeWithIndex(5, (function (param) {
          return 1 + param | 0;
        }));
  var attempts = Relude_List.filter((function (param) {
          if (Curry._1(Relude_List.length, pathToChars(param[0])) <= 20) {
            return Curry._1(Relude_List.length, pathToChars(param[1])) <= 20;
          } else {
            return false;
          }
        }), Curry._3(Relude_List.map2, (function (s, e) {
              var start = Relude_List.take(s, path);
              var end_ = Relude_List.drop(pathLength - e | 0, path);
              return /* tuple */[
                      start,
                      end_
                    ];
            }), lengths, lengths));
  var raw = Relude_List.map((function (param) {
            return /* Raw */Block.__(0, [
                      param[0],
                      param[1]
                    ]);
          }))(path);
  var compressed = Relude_List.map((function (param) {
            var e = param[1];
            var s = param[0];
            var a = replace(/* "A" */65, s, raw);
            var b = replace(/* "B" */66, e, a);
            var remaining = Relude_List.mapOption((function (param) {
                    if (param.tag) {
                      return ;
                    } else {
                      return /* tuple */[
                              param[0],
                              param[1]
                            ];
                    }
                  }), Relude_List.takeWhile((function (param) {
                        if (param.tag) {
                          return false;
                        } else {
                          return true;
                        }
                      }), Relude_List.dropWhile((function (param) {
                            if (param.tag) {
                              return true;
                            } else {
                              return false;
                            }
                          }), b)));
            var c = replace(/* "C" */67, remaining, b);
            return /* tuple */[
                    s,
                    e,
                    remaining,
                    c
                  ];
          }))(attempts);
  var valid = Relude_List.filter((function (param) {
          return Curry._2(Relude_List.all, (function (param) {
                        if (param.tag) {
                          return true;
                        } else {
                          return false;
                        }
                      }), param[3]);
        }), compressed);
  var match = Relude_Option.getOrThrow(Relude_List.head(valid));
  return /* tuple */[
          charsToAscii(compressedToChars(match[3])),
          charsToAscii(pathToChars(match[0])),
          charsToAscii(pathToChars(match[1])),
          charsToAscii(pathToChars(match[2]))
        ];
}

var input = InputLoader$Aoc19.commaSeparated(17);

var image = Curry._2(StackSafeFuture$Aoc19.flatMap, takeImage, input);

StackSafeFuture$Aoc19.tap((function (param) {
          return Relude_Function.flipCompose((function (param) {
                        return Relude_Function.flipCompose(findIntersection, intersectionsToAlignmentParameters, param);
                      }), (function (param) {
                        console.log("sum of the alignment parameters", param);
                        return /* () */0;
                      }), param);
        }))(image);

var compressed = StackSafeFuture$Aoc19.map((function (param) {
        return Relude_Function.flipCompose(findPath, compress, param);
      }), image);

StackSafeFuture$Aoc19.tap((function (param) {
          console.log("Dust", param);
          return /* () */0;
        }))(Curry._1(StackSafeFuture$Aoc19.flatten, Curry._3(StackSafeFuture$Aoc19.map2, (function (i, c) {
                return run(c, i);
              }), input, compressed)));

var CoordMap = /* alias */0;

var $great$great = Relude_Function.flipCompose;

exports.CoordMap = CoordMap;
exports.$great$great = $great$great;
exports.spriteToDisplay = spriteToDisplay;
exports.$$Screen = $$Screen;
exports.Camera = Camera;
exports.Robot = Robot;
exports.findIntersection = findIntersection;
exports.intersectionsToAlignmentParameters = intersectionsToAlignmentParameters;
exports.nextPosition = nextPosition;
exports.leftRight = leftRight;
exports.InvalidState = InvalidState;
exports.findPath = findPath;
exports.xToChars = xToChars;
exports.pathToChars = pathToChars;
exports.charsToAscii = charsToAscii;
exports.compressedToChars = compressedToChars;
exports.replace = replace;
exports.compress = compress;
exports.input = input;
exports.image = image;
exports.compressed = compressed;
/* partial_arg Not a pure module */
