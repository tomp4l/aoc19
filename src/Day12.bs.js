// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var Relude_Ordering = require("relude/src/Relude_Ordering.bs.js");
var Relude_List_Specializations = require("relude/src/list/Relude_List_Specializations.bs.js");

var id = /* record */[/* contents */0];

function make(position) {
  id[0] = id[0] + 1 | 0;
  return /* record */[
          /* position */position,
          /* velocity : tuple */[
            0,
            0,
            0
          ],
          /* id */id[0]
        ];
}

function modifyVelocity(id, param, map) {
  var moon = Relude_Option.getOrThrow(Curry._2(Relude_Int.$$Map.get, id, map));
  var match = moon[/* velocity */1];
  var moon_000 = /* position */moon[/* position */0];
  var moon_001 = /* velocity : tuple */[
    match[0] + param[0] | 0,
    match[1] + param[1] | 0,
    match[2] + param[2] | 0
  ];
  var moon_002 = /* id */moon[/* id */2];
  var moon$1 = /* record */[
    moon_000,
    moon_001,
    moon_002
  ];
  return Curry._3(Relude_Int.$$Map.set, id, moon$1, map);
}

function makePairs(moons) {
  var pairs = function (moon, rest) {
    var newPairs = Relude_List.map((function (m) {
              return /* tuple */[
                      moon,
                      m
                    ];
            }))(rest);
    if (rest) {
      return /* :: */[
              newPairs,
              pairs(rest[0], rest[1])
            ];
    } else {
      return /* :: */[
              newPairs,
              /* [] */0
            ];
    }
  };
  return Curry._1(Relude_List.flatten, pairs(Relude_Option.getOrThrow(Relude_List.head(moons)), Relude_List.tailOrEmpty(moons)));
}

function step(moons) {
  var pairs = makePairs(moons);
  var map = Curry._1(Relude_Int.$$Map.fromList, Relude_List.map((function (moon) {
                return /* tuple */[
                        moon[/* id */2],
                        moon
                      ];
              }))(moons));
  return Relude_List.map((function (moon) {
                  var match = moon[/* velocity */1];
                  var match$1 = moon[/* position */0];
                  return /* record */[
                          /* position : tuple */[
                            match$1[0] + match[0] | 0,
                            match$1[1] + match[1] | 0,
                            match$1[2] + match[2] | 0
                          ],
                          /* velocity */moon[/* velocity */1],
                          /* id */moon[/* id */2]
                        ];
                }))(Curry._1(Relude_Int.$$Map.values, Relude_List.foldLeft((function (map, param) {
                          var m2 = param[1];
                          var match = m2[/* position */0];
                          var m1 = param[0];
                          var match$1 = m1[/* position */0];
                          var x$prime = Relude_Ordering.toInt(Curry._2(Relude_Int.Ord.compare, match$1[0], match[0]));
                          var y$prime = Relude_Ordering.toInt(Curry._2(Relude_Int.Ord.compare, match$1[1], match[1]));
                          var z$prime = Relude_Ordering.toInt(Curry._2(Relude_Int.Ord.compare, match$1[2], match[2]));
                          return modifyVelocity(m1[/* id */2], /* tuple */[
                                      -x$prime | 0,
                                      -y$prime | 0,
                                      -z$prime | 0
                                    ], modifyVelocity(m2[/* id */2], /* tuple */[
                                          x$prime,
                                          y$prime,
                                          z$prime
                                        ], map));
                        }), map)(pairs)));
}

function stepUntil(iterations, moons) {
  var _ms = moons;
  var _i = 0;
  while(true) {
    var i = _i;
    var ms = _ms;
    if (i === iterations) {
      return ms;
    } else {
      _i = i + 1 | 0;
      _ms = step(ms);
      continue ;
    }
  };
}

function energy(param) {
  var match = param[/* velocity */1];
  var match$1 = param[/* position */0];
  return Caml_int32.imul((Pervasives.abs(match$1[0]) + Pervasives.abs(match$1[1]) | 0) + Pervasives.abs(match$1[2]) | 0, (Pervasives.abs(match[0]) + Pervasives.abs(match[1]) | 0) + Pervasives.abs(match[2]) | 0);
}

function loopDetector(extract, moons) {
  var partial_arg = Relude_List.map(extract);
  var extractAll = function (param) {
    return Relude_Function.flipCompose(partial_arg, Relude_List.flatten, param);
  };
  var initial = Curry._1(extractAll, moons);
  var _moons = moons;
  var _i = 0;
  while(true) {
    var i = _i;
    var moons$1 = _moons;
    var next = step(moons$1);
    var e = Curry._1(extractAll, next);
    var match = Caml_obj.caml_equal(e, initial);
    if (match) {
      return i + 1 | 0;
    } else {
      _i = i + 1 | 0;
      _moons = next;
      continue ;
    }
  };
}

var Moon = {
  id: id,
  make: make,
  modifyVelocity: modifyVelocity,
  makePairs: makePairs,
  step: step,
  stepUntil: stepUntil,
  energy: energy,
  loopDetector: loopDetector
};

function lcm(nums) {
  var bigNums = Relude_List.map(Caml_int64.of_int32)(nums);
  var loop = function (_i, _nums) {
    while(true) {
      var nums = _nums;
      var i = _i;
      var match = Relude_List.partition((function(i){
          return function (x) {
            return Caml_int64.eq(Caml_int64.mod_(x, i), Int64.zero);
          }
          }(i)), nums);
      var n = match[1];
      var d = match[0];
      if (d) {
        var divided = Relude_List.filterNot((function (param) {
                  return Caml_obj.caml_equal(Int64.one, param);
                }))(Relude_List.map((function(i){
                  return function (d) {
                    return Caml_int64.div(d, i);
                  }
                  }(i)))(d));
        return Caml_int64.mul(i, loop(i, Relude_List.concat(divided, n)));
      } else if (n) {
        _nums = n;
        _i = Caml_int64.add(Int64.one, i);
        continue ;
      } else {
        return Int64.one;
      }
    };
  };
  return loop(/* int64 */[
              /* hi */0,
              /* lo */2
            ], bigNums);
}

var initialMoons_000 = make(/* tuple */[
      16,
      -11,
      2
    ]);

var initialMoons_001 = /* :: */[
  make(/* tuple */[
        0,
        -4,
        7
      ]),
  /* :: */[
    make(/* tuple */[
          6,
          4,
          -10
        ]),
    /* :: */[
      make(/* tuple */[
            -3,
            -2,
            -4
          ]),
      /* [] */0
    ]
  ]
];

var initialMoons = /* :: */[
  initialMoons_000,
  initialMoons_001
];

console.log(" Energy after 1000", Curry._1(Relude_List_Specializations.Int.sum, Relude_List.map(energy)(stepUntil(1000, initialMoons))));

var xLoop = loopDetector((function (param) {
        return /* :: */[
                param[/* position */0][0],
                /* :: */[
                  param[/* velocity */1][0],
                  /* [] */0
                ]
              ];
      }), initialMoons);

var yLoop = loopDetector((function (param) {
        return /* :: */[
                param[/* position */0][1],
                /* :: */[
                  param[/* velocity */1][1],
                  /* [] */0
                ]
              ];
      }), initialMoons);

var zLoop = loopDetector((function (param) {
        return /* :: */[
                param[/* position */0][2],
                /* :: */[
                  param[/* velocity */1][2],
                  /* [] */0
                ]
              ];
      }), initialMoons);

console.log("Repeating loop after:", Int64.to_string(lcm(/* :: */[
              xLoop,
              /* :: */[
                yLoop,
                /* :: */[
                  zLoop,
                  /* [] */0
                ]
              ]
            ])));

var $great$great = Relude_Function.flipCompose;

exports.$great$great = $great$great;
exports.Moon = Moon;
exports.lcm = lcm;
exports.initialMoons = initialMoons;
exports.xLoop = xLoop;
exports.yLoop = yLoop;
exports.zLoop = zLoop;
/* initialMoons Not a pure module */
