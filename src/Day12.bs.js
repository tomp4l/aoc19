// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var Relude_Ordering = require("relude/src/Relude_Ordering.bs.js");
var Relude_List_Specializations = require("relude/src/list/Relude_List_Specializations.bs.js");

var id = {
  contents: 0
};

function make(position) {
  id.contents = id.contents + 1 | 0;
  return {
          position: position,
          velocity: [
            0,
            0,
            0
          ],
          id: id.contents
        };
}

function modifyVelocity(id, param, map) {
  var moon = Relude_Option.getOrThrow(Curry._2(Relude_Int.$$Map.get, id, map));
  var match = moon.velocity;
  var moon_position = moon.position;
  var moon_velocity = [
    match[0] + param[0] | 0,
    match[1] + param[1] | 0,
    match[2] + param[2] | 0
  ];
  var moon_id = moon.id;
  var moon$1 = {
    position: moon_position,
    velocity: moon_velocity,
    id: moon_id
  };
  return Curry._3(Relude_Int.$$Map.set, id, moon$1, map);
}

function makePairs(moons) {
  var pairs = function (moon, rest) {
    var newPairs = Relude_List.map(function (m) {
            return [
                    moon,
                    m
                  ];
          })(rest);
    if (rest) {
      return {
              hd: newPairs,
              tl: pairs(rest.hd, rest.tl)
            };
    } else {
      return {
              hd: newPairs,
              tl: /* [] */0
            };
    }
  };
  return Curry._1(Relude_List.flatten, pairs(Relude_Option.getOrThrow(Relude_List.head(moons)), Relude_List.tailOrEmpty(moons)));
}

function step(moons) {
  var pairs = makePairs(moons);
  var map = Curry._1(Relude_Int.$$Map.fromList, Relude_List.map(function (moon) {
              return [
                      moon.id,
                      moon
                    ];
            })(moons));
  return Relude_List.map(function (moon) {
                var match = moon.velocity;
                var match$1 = moon.position;
                return {
                        position: [
                          match$1[0] + match[0] | 0,
                          match$1[1] + match[1] | 0,
                          match$1[2] + match[2] | 0
                        ],
                        velocity: moon.velocity,
                        id: moon.id
                      };
              })(Curry._1(Relude_Int.$$Map.values, Relude_List.foldLeft((function (map, param) {
                          var m2 = param[1];
                          var match = m2.position;
                          var m1 = param[0];
                          var match$1 = m1.position;
                          var x$prime = Relude_Ordering.toInt(Curry._2(Relude_Int.Ord.compare, match$1[0], match[0]));
                          var y$prime = Relude_Ordering.toInt(Curry._2(Relude_Int.Ord.compare, match$1[1], match[1]));
                          var z$prime = Relude_Ordering.toInt(Curry._2(Relude_Int.Ord.compare, match$1[2], match[2]));
                          return modifyVelocity(m1.id, [
                                      -x$prime | 0,
                                      -y$prime | 0,
                                      -z$prime | 0
                                    ], modifyVelocity(m2.id, [
                                          x$prime,
                                          y$prime,
                                          z$prime
                                        ], map));
                        }), map)(pairs)));
}

function stepUntil(iterations, moons) {
  var _ms = moons;
  var _i = 0;
  while(true) {
    var i = _i;
    var ms = _ms;
    if (i === iterations) {
      return ms;
    }
    _i = i + 1 | 0;
    _ms = step(ms);
    continue ;
  };
}

function energy(param) {
  var match = param.velocity;
  var match$1 = param.position;
  return Math.imul((Pervasives.abs(match$1[0]) + Pervasives.abs(match$1[1]) | 0) + Pervasives.abs(match$1[2]) | 0, (Pervasives.abs(match[0]) + Pervasives.abs(match[1]) | 0) + Pervasives.abs(match[2]) | 0);
}

function loopDetector(extract, moons) {
  var partial_arg = Relude_List.map(extract);
  var extractAll = function (param) {
    return Relude_Function.flipCompose(partial_arg, Relude_List.flatten, param);
  };
  var initial = Curry._1(extractAll, moons);
  var _moons = moons;
  var _i = 0;
  while(true) {
    var i = _i;
    var moons$1 = _moons;
    var next = step(moons$1);
    var e = Curry._1(extractAll, next);
    if (Caml_obj.caml_equal(e, initial)) {
      return i + 1 | 0;
    }
    _i = i + 1 | 0;
    _moons = next;
    continue ;
  };
}

var Moon = {
  id: id,
  make: make,
  modifyVelocity: modifyVelocity,
  makePairs: makePairs,
  step: step,
  stepUntil: stepUntil,
  energy: energy,
  loopDetector: loopDetector
};

function lcm(nums) {
  var bigNums = Relude_List.map(Caml_int64.of_int32)(nums);
  var loop = function (_i, _nums) {
    while(true) {
      var nums = _nums;
      var i = _i;
      var match = Relude_List.partition((function(i){
          return function (x) {
            return Caml_int64.eq(Caml_int64.mod_(x, i), Int64.zero);
          }
          }(i)), nums);
      var n = match[1];
      var d = match[0];
      if (d) {
        var divided = Relude_List.filterNot(function (param) {
                return Caml_int64.eq(Int64.one, param);
              })(Relude_List.map((function(i){
                  return function (d) {
                    return Caml_int64.div(d, i);
                  }
                  }(i)))(d));
        return Caml_int64.mul(i, loop(i, Relude_List.concat(divided, n)));
      }
      if (!n) {
        return Int64.one;
      }
      _nums = n;
      _i = Caml_int64.add(Int64.one, i);
      continue ;
    };
  };
  return loop(Caml_int64.mk(2, 0), bigNums);
}

var initialMoons_0 = make([
      16,
      -11,
      2
    ]);

var initialMoons_1 = {
  hd: make([
        0,
        -4,
        7
      ]),
  tl: {
    hd: make([
          6,
          4,
          -10
        ]),
    tl: {
      hd: make([
            -3,
            -2,
            -4
          ]),
      tl: /* [] */0
    }
  }
};

var initialMoons = {
  hd: initialMoons_0,
  tl: initialMoons_1
};

console.log(" Energy after 1000", Curry._1(Relude_List_Specializations.Int.sum, Relude_List.map(energy)(stepUntil(1000, initialMoons))));

var xLoop = loopDetector((function (param) {
        return {
                hd: param.position[0],
                tl: {
                  hd: param.velocity[0],
                  tl: /* [] */0
                }
              };
      }), initialMoons);

var yLoop = loopDetector((function (param) {
        return {
                hd: param.position[1],
                tl: {
                  hd: param.velocity[1],
                  tl: /* [] */0
                }
              };
      }), initialMoons);

var zLoop = loopDetector((function (param) {
        return {
                hd: param.position[2],
                tl: {
                  hd: param.velocity[2],
                  tl: /* [] */0
                }
              };
      }), initialMoons);

console.log("Repeating loop after:", Int64.to_string(lcm({
              hd: xLoop,
              tl: {
                hd: yLoop,
                tl: {
                  hd: zLoop,
                  tl: /* [] */0
                }
              }
            })));

var $great$great = Relude_Function.flipCompose;

exports.$great$great = $great$great;
exports.Moon = Moon;
exports.lcm = lcm;
exports.initialMoons = initialMoons;
exports.xLoop = xLoop;
exports.yLoop = yLoop;
exports.zLoop = zLoop;
/* initialMoons Not a pure module */
