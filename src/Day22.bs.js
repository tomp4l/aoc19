// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int32 = require("bs-platform/lib/js/int32.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Array = require("relude/src/Relude_Array.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");
var Relude_List_Specializations = require("relude/src/list/Relude_List_Specializations.bs.js");

function mul(a, b, m) {
  var maxInt32 = Caml_int64.of_int32(Int32.max_int);
  var lessThan32Bit = function (a) {
    return Int64.compare(Int64.abs(a), maxInt32) < 1;
  };
  if (lessThan32Bit(a) && lessThan32Bit(b)) {
    return Caml_int64.mod_(Caml_int64.mul(a, b), m);
  }
  var _am = Caml_int64.mod_(a, m);
  var _bm = Caml_int64.mod_(b, m);
  var _r = Int64.zero;
  while(true) {
    var r = _r;
    var bm = _bm;
    var am = _am;
    if (Int64.equal(Int64.zero, bm)) {
      return r;
    }
    var add = Int64.equal(Int64.one, Caml_int64.and_(Int64.one, bm)) ? am : Int64.zero;
    var am$prime = Caml_int64.mod_(Caml_int64.lsl_(am, 1), m);
    var bm$prime = Caml_int64.asr_(bm, 1);
    var r$prime = Caml_int64.mod_(Caml_int64.add(add, r), m);
    _r = r$prime;
    _bm = bm$prime;
    _am = am$prime;
    continue ;
  };
}

function pow(a, n, m) {
  var _a = a;
  var _n = n;
  var _r = Int64.one;
  while(true) {
    var r = _r;
    var n$1 = _n;
    var a$1 = _a;
    if (Int64.equal(Int64.zero, n$1)) {
      return r;
    }
    var r$prime = Int64.equal(Int64.one, Caml_int64.and_(Int64.one, n$1)) ? mul(r, a$1, m) : r;
    var n$prime = Caml_int64.asr_(n$1, 1);
    var a$prime = mul(a$1, a$1, m);
    _r = r$prime;
    _n = n$prime;
    _a = a$prime;
    continue ;
  };
}

function inv_prime(a, m) {
  return pow(a, Caml_int64.sub(m, Caml_format.caml_int64_of_string("2")), m);
}

var Modulo = {
  mul: mul,
  pow: pow,
  inv_prime: inv_prime
};

function cutNCards(n, deck) {
  var x = n >= 0 ? n : Curry._1(Relude_List.length, deck) + n | 0;
  var start = Relude_List.take(x, deck);
  var rest = Relude_List.drop(x, deck);
  return Relude_List.concat(rest, start);
}

function dealWithIncrementN(n, deck) {
  var length = Curry._1(Relude_List.length, deck);
  var start = Relude_Array.makeWithIndex(length, (function (param) {
          
        }));
  var _remaining = deck;
  var _index = 0;
  while(true) {
    var index = _index;
    var remaining = _remaining;
    if (!remaining) {
      return Relude_Array.toList(Relude_Array.mapOption(Relude_Function.identity, start));
    }
    Relude_Array.setAt(index, Caml_option.some(remaining.hd), start);
    var i = index + n | 0;
    var ii = i >= length ? i - length | 0 : i;
    _index = ii;
    _remaining = remaining.tl;
    continue ;
  };
}

function factory(n) {
  var _acc = /* [] */0;
  var _n = n - 1 | 0;
  while(true) {
    var n$1 = _n;
    var acc = _acc;
    if (n$1 < 0) {
      return acc;
    }
    _n = n$1 - 1 | 0;
    _acc = {
      hd: n$1,
      tl: acc
    };
    continue ;
  };
}

function runProgram(n, lines) {
  var deck = factory(n);
  var _l = lines;
  var _d = deck;
  while(true) {
    var d = _d;
    var l = _l;
    if (!l) {
      return d;
    }
    var h = l.hd;
    var newD;
    if (h === "deal into new stack") {
      newD = Relude_List.reverse(d);
    } else if (Relude_String.startsWith("cut", h)) {
      var n$1 = Caml_format.caml_int_of_string(Relude_String.removeFirst("cut ", h));
      newD = cutNCards(n$1, d);
    } else {
      var n$2 = Caml_format.caml_int_of_string(Relude_String.removeFirst("deal with increment ", h));
      newD = dealWithIncrementN(n$2, d);
    }
    _d = newD;
    _l = l.tl;
    continue ;
  };
}

function moduloProgram(size, shuffles, position, lines) {
  var loop = function (_l, _a, _b) {
    while(true) {
      var b = _b;
      var a = _a;
      var l = _l;
      if (!l) {
        return [
                a,
                b
              ];
      }
      var h = l.hd;
      var match;
      if (h === "deal into new stack") {
        match = [
          Caml_int64.sub(size, a),
          Caml_int64.mod_(Caml_int64.add(size, Caml_int64.sub(b, a)), size)
        ];
      } else if (Relude_String.startsWith("cut", h)) {
        var n = Caml_int64.add(size, Caml_format.caml_int64_of_string(Relude_String.removeFirst("cut ", h)));
        match = [
          a,
          Caml_int64.mod_(Caml_int64.add(b, mul(n, a, size)), size)
        ];
      } else {
        var n$1 = Caml_format.caml_int64_of_string(Relude_String.removeFirst("deal with increment ", h));
        var z = inv_prime(n$1, size);
        match = [
          mul(a, z, size),
          b
        ];
      }
      _b = match[1];
      _a = match[0];
      _l = l.tl;
      continue ;
    };
  };
  var pow = function (_a, _b, _m, n) {
    while(true) {
      var m = _m;
      var b = _b;
      var a = _a;
      if (Int64.equal(m, Int64.zero)) {
        return [
                Int64.one,
                Int64.zero
              ];
      }
      if (Int64.equal(Caml_int64.mod_(m, Caml_format.caml_int64_of_string("2")), Int64.zero)) {
        _m = Caml_int64.div(m, Caml_format.caml_int64_of_string("2"));
        _b = Caml_int64.mod_(Caml_int64.add(b, mul(a, b, n)), n);
        _a = mul(a, a, n);
        continue ;
      }
      var match = pow(a, b, Caml_int64.sub(m, Int64.one), n);
      return [
              mul(a, match[0], n),
              Caml_int64.mod_(Caml_int64.add(b, mul(a, match[1], n)), n)
            ];
    };
  };
  var match = loop(lines, Int64.one, Int64.zero);
  var match$1 = pow(match[0], match[1], shuffles, size);
  return Caml_int64.mod_(Caml_int64.add(Caml_int64.mul(position, match$1[0]), match$1[1]), size);
}

var Deal = {
  dealIntoNewStack: Relude_List.reverse,
  cutNCards: cutNCards,
  dealWithIncrementN: dealWithIncrementN,
  factory: factory,
  runProgram: runProgram,
  moduloProgram: moduloProgram
};

var input = InputLoader$Aoc19.newlineSeparated(22);

StackSafeFuture$Aoc19.tap(function (l) {
        console.log(Curry._2(Relude_List_Specializations.Int.indexOf, 2019, runProgram(10007, l)));
        
      })(input);

StackSafeFuture$Aoc19.tap(function (l) {
        console.log(Int64.to_string(moduloProgram(Caml_format.caml_int64_of_string("119315717514047"), Caml_format.caml_int64_of_string("101741582076661"), Caml_format.caml_int64_of_string("2020"), l)));
        
      })(input);

exports.Modulo = Modulo;
exports.Deal = Deal;
exports.input = input;
/* input Not a pure module */
