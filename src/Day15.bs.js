// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Intcode$Aoc19 = require("./Intcode.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

function directionToInt(param) {
  switch (param) {
    case /* North */0 :
        return 1;
    case /* South */1 :
        return 2;
    case /* East */2 :
        return 4;
    case /* West */3 :
        return 3;
    
  }
}

function move(param, param$1) {
  var y = param[1];
  var x = param[0];
  switch (param$1) {
    case /* North */0 :
        return /* tuple */[
                x,
                y - 1 | 0
              ];
    case /* South */1 :
        return /* tuple */[
                x,
                y + 1 | 0
              ];
    case /* East */2 :
        return /* tuple */[
                x + 1 | 0,
                y
              ];
    case /* West */3 :
        return /* tuple */[
                x - 1 | 0,
                y
              ];
    
  }
}

function roomToDisplay(param) {
  switch (param) {
    case /* Unknown */0 :
        return " ";
    case /* Wall */1 :
        return "#";
    case /* Floor */2 :
        return ".";
    case /* OxygenSystem */3 :
        return "O";
    
  }
}

function get(c) {
  var partial_arg = Curry._1(Coord$Aoc19.CoordMap.get, c);
  return (function (param) {
      return Relude_Function.flipCompose(partial_arg, (function (param) {
                    return Relude_Option.getOrElse(/* Unknown */0, param);
                  }), param);
    });
}

var reveal = Coord$Aoc19.CoordMap.set;

function make(p, r) {
  return Curry._3(reveal, p, r, Curry._1(Coord$Aoc19.CoordMap.make, /* () */0));
}

function drawShip(param) {
  return Coord$Aoc19.output(roomToDisplay, /* Unknown */0, param);
}

var Ship = {
  get: get,
  reveal: reveal,
  make: make,
  drawShip: drawShip
};

var UnknownInput = Caml_exceptions.create("Day15-Aoc19.Robot.UnknownInput");

function nextDirection(ship, position, history) {
  var c = move(position, /* North */0);
  var n = get(c)(ship);
  var c$1 = move(position, /* South */1);
  var s = get(c$1)(ship);
  var c$2 = move(position, /* East */2);
  var e = get(c$2)(ship);
  var c$3 = move(position, /* West */3);
  var w = get(c$3)(ship);
  if (n !== 0) {
    if (s !== 0) {
      if (e !== 0) {
        if (w !== 0) {
          return Relude_Option.getOrElse(/* tuple */[
                      /* West */3,
                      /* [] */0
                    ], Relude_Option.map((function (d) {
                            return /* tuple */[
                                    d,
                                    Relude_List.tailOrEmpty(history)
                                  ];
                          }), Relude_Option.map((function (d) {
                                switch (d) {
                                  case /* North */0 :
                                      return /* South */1;
                                  case /* South */1 :
                                      return /* North */0;
                                  case /* East */2 :
                                      return /* West */3;
                                  case /* West */3 :
                                      return /* East */2;
                                  
                                }
                              }), Relude_List.head(history))));
        } else {
          return /* tuple */[
                  /* West */3,
                  /* :: */[
                    /* West */3,
                    history
                  ]
                ];
        }
      } else {
        return /* tuple */[
                /* East */2,
                /* :: */[
                  /* East */2,
                  history
                ]
              ];
      }
    } else {
      return /* tuple */[
              /* South */1,
              /* :: */[
                /* South */1,
                history
              ]
            ];
    }
  } else {
    return /* tuple */[
            /* North */0,
            /* :: */[
              /* North */0,
              history
            ]
          ];
  }
}

function findOxygenSystem($staropt$star, $staropt$star$1, findSensor, input) {
  var display = $staropt$star !== undefined ? $staropt$star : false;
  var delay = $staropt$star$1 !== undefined ? $staropt$star$1 : 0;
  return StackSafeFuture$Aoc19.make((function (resolve) {
                var position = /* record */[/* contents : tuple */[
                    0,
                    0
                  ]];
                var lastMove = /* record */[/* contents : East */2];
                var ship = /* record */[/* contents */make(position[0], /* Floor */2)];
                var history = /* record */[/* contents : [] */0];
                var totalDistance = /* record */[/* contents */0];
                var maxDistance = /* record */[/* contents */0];
                var found = /* record */[/* contents */false];
                var finished = /* record */[/* contents */false];
                var nextInput = function (param) {
                  var match = finished[0];
                  if (match) {
                    return StackSafeFuture$Aoc19.never(/* () */0);
                  } else if (delay !== 0) {
                    return StackSafeFuture$Aoc19.delay(delay, (function (param) {
                                  return String(directionToInt(lastMove[0]));
                                }));
                  } else {
                    return StackSafeFuture$Aoc19.pure(String(directionToInt(lastMove[0])));
                  }
                };
                var nextOutput = function (v) {
                  switch (v) {
                    case "0" :
                        var attempt = move(position[0], lastMove[0]);
                        ship[0] = Curry._3(reveal, attempt, /* Wall */1, ship[0]);
                        history[0] = Relude_List.tailOrEmpty(history[0]);
                        break;
                    case "1" :
                        position[0] = move(position[0], lastMove[0]);
                        var match = get(position[0])(ship[0]);
                        if (match !== 0) {
                          totalDistance[0] = totalDistance[0] - 1 | 0;
                        } else {
                          totalDistance[0] = totalDistance[0] + 1 | 0;
                        }
                        ship[0] = Curry._3(reveal, position[0], /* Floor */2, ship[0]);
                        break;
                    case "2" :
                        position[0] = move(position[0], lastMove[0]);
                        ship[0] = Curry._3(reveal, position[0], /* OxygenSystem */3, ship[0]);
                        if (findSensor) {
                          finished[0] = true;
                          Curry._1(resolve, totalDistance[0] + 1 | 0);
                        } else if (found[0]) {
                          finished[0] = true;
                          Curry._1(resolve, maxDistance[0]);
                        } else {
                          ship[0] = make(position[0], /* OxygenSystem */3);
                          history[0] = /* [] */0;
                          totalDistance[0] = 0;
                          maxDistance[0] = 0;
                          found[0] = true;
                        }
                        break;
                    default:
                      throw [
                            UnknownInput,
                            v
                          ];
                  }
                  var match$1 = nextDirection(ship[0], position[0], history[0]);
                  lastMove[0] = match$1[0];
                  history[0] = match$1[1];
                  maxDistance[0] = Curry._2(Relude_Int.max, maxDistance[0], totalDistance[0]);
                  if (display) {
                    console.log("");
                    Coord$Aoc19.output(roomToDisplay, /* Unknown */0, ship[0]);
                    console.log("distance", totalDistance[0]);
                  }
                  return /* () */0;
                };
                Intcode$Aoc19.run(nextInput, nextOutput, input);
                return /* () */0;
              }));
}

var Robot = {
  UnknownInput: UnknownInput,
  nextDirection: nextDirection,
  findOxygenSystem: findOxygenSystem
};

var input = InputLoader$Aoc19.commaSeparated(15);

StackSafeFuture$Aoc19.tap((function (param) {
          console.log("Position", param);
          return /* () */0;
        }))(Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
            return findOxygenSystem(undefined, undefined, true, param);
          }), input));

StackSafeFuture$Aoc19.tap((function (param) {
          console.log("Time for oxygen to diffuse", param);
          return /* () */0;
        }))(Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
            return findOxygenSystem(undefined, undefined, false, param);
          }), input));

var CoordMap = 0;

var $great$great = Relude_Function.flipCompose;

exports.CoordMap = CoordMap;
exports.$great$great = $great$great;
exports.directionToInt = directionToInt;
exports.move = move;
exports.roomToDisplay = roomToDisplay;
exports.Ship = Ship;
exports.Robot = Robot;
exports.input = input;
/* input Not a pure module */
