// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");
var Relude_List_Specializations = require("relude/src/list/Relude_List_Specializations.bs.js");

var InvalidDirection = Caml_exceptions.create("Day3-Aoc19.InvalidDirection");

var $great$great = Relude_Function.Infix.$great$great;

function stringToDirection(s) {
  var split = Relude_String.splitAt(1, s);
  var l = split[0];
  switch (l) {
    case "D" :
        return {
                TAG: /* Down */3,
                _0: Caml_format.caml_int_of_string(split[1])
              };
    case "L" :
        return {
                TAG: /* Left */2,
                _0: Caml_format.caml_int_of_string(split[1])
              };
    case "R" :
        return {
                TAG: /* Right */0,
                _0: Caml_format.caml_int_of_string(split[1])
              };
    case "U" :
        return {
                TAG: /* Up */1,
                _0: Caml_format.caml_int_of_string(split[1])
              };
    default:
      throw {
            RE_EXN_ID: InvalidDirection,
            _1: l,
            Error: new Error()
          };
  }
}

function distance(d) {
  return d._0;
}

function pathFromDirection(direction, coord) {
  var _path = /* [] */0;
  var _dir = direction;
  var _coord$prime = coord;
  while(true) {
    var coord$prime = _coord$prime;
    var dir = _dir;
    var path = _path;
    var y = coord$prime[1];
    var x = coord$prime[0];
    if (dir._0 <= 0) {
      return path;
    }
    var nextDistance = dir._0 - 1 | 0;
    var match;
    switch (dir.TAG | 0) {
      case /* Right */0 :
          match = [
            [
              x + 1 | 0,
              y
            ],
            {
              TAG: /* Right */0,
              _0: nextDistance
            }
          ];
          break;
      case /* Up */1 :
          match = [
            [
              x,
              y + 1 | 0
            ],
            {
              TAG: /* Up */1,
              _0: nextDistance
            }
          ];
          break;
      case /* Left */2 :
          match = [
            [
              x - 1 | 0,
              y
            ],
            {
              TAG: /* Left */2,
              _0: nextDistance
            }
          ];
          break;
      case /* Down */3 :
          match = [
            [
              x,
              y - 1 | 0
            ],
            {
              TAG: /* Down */3,
              _0: nextDistance
            }
          ];
          break;
      
    }
    var nextCoord = match[0];
    _coord$prime = nextCoord;
    _dir = match[1];
    _path = {
      hd: nextCoord,
      tl: path
    };
    continue ;
  };
}

function pathFromDirections(directions) {
  return Relude_List.foldLeft((function (acc, dir) {
                  var current = Relude_List.head(acc);
                  var path = Curry._1(Relude_List.flatten, Curry._1(Relude_Option.toList, Relude_Option.map((function (param) {
                                  return pathFromDirection(dir, param);
                                }), current)));
                  return Relude_List.concat(path, acc);
                }), {
                hd: [
                  0,
                  0
                ],
                tl: /* [] */0
              })(directions);
}

function getCrossings(a, b) {
  var aSet = Curry._1(Coord$Aoc19.CoordSet.fromList, a);
  var bSet = Curry._1(Coord$Aoc19.CoordSet.fromList, b);
  return Curry._2(Coord$Aoc19.CoordSet.remove, [
              0,
              0
            ], Curry._2(Coord$Aoc19.CoordSet.intersect, aSet, bSet));
}

function manhattenDistance(coord) {
  return Curry._1(Relude_Int.abs, coord[0]) + Curry._1(Relude_Int.abs, coord[1]) | 0;
}

function getClosestToOrigin(coords) {
  return Relude_Option.getOrThrow(Relude_List.head(Relude_List.sortBy((function (a, b) {
                        return Curry._2(Relude_Int.compare, manhattenDistance(a), manhattenDistance(b));
                      }), coords)));
}

function addDistanceToPath(path) {
  var pathLength = Curry._1(Relude_List.length, path);
  return Relude_List.mapWithIndex((function (v, i) {
                return [
                        v,
                        (pathLength - i | 0) - 1 | 0
                      ];
              }), path);
}

function addDistancesToMap(path, map) {
  return Relude_List.foldLeft((function (map, coordWithDistance) {
                  var coord = coordWithDistance[0];
                  var d = Curry._2(Coord$Aoc19.CoordMap.get, coord, map);
                  if (d !== undefined) {
                    return Curry._3(Coord$Aoc19.CoordMap.set, coord, d + coordWithDistance[1] | 0, map);
                  } else {
                    return map;
                  }
                }), map)(path);
}

function findClosestIntersection(pathA, pathB) {
  var intersections = Curry._1(Coord$Aoc19.CoordSet.toList, getCrossings(pathA, pathB));
  var intersectionsWithDistance = Belt_List.zip(intersections, Belt_List.make(Belt_List.length(intersections), 0));
  var intersectionsMap = Curry._1(Coord$Aoc19.CoordMap.fromList, intersectionsWithDistance);
  var pathADistances = addDistanceToPath(pathA);
  var pathBDistances = addDistanceToPath(pathB);
  var intersectionsMap$1 = addDistancesToMap(pathADistances, intersectionsMap);
  var intersectionsMap$2 = addDistancesToMap(pathBDistances, intersectionsMap$1);
  return Curry._1(Relude_List_Specializations.Int.min, Curry._1(Coord$Aoc19.CoordMap.values, intersectionsMap$2));
}

var partial_arg = Relude_List.map(pathFromDirections);

var partial_arg$1 = Relude_List.map(stringToDirection);

var partial_arg$2 = Relude_List.map(function (param) {
      return $great$great((function (param) {
                    return Relude_String.splitList(",", param);
                  }), partial_arg$1, param);
    });

var input = StackSafeFuture$Aoc19.map((function (param) {
        return $great$great(partial_arg$2, partial_arg, param);
      }), InputLoader$Aoc19.newlineSeparated(3));

StackSafeFuture$Aoc19.tap(function (a) {
        if (!a) {
          return ;
        }
        var match = a.tl;
        if (match && !match.tl) {
          console.log("Closest to origin", manhattenDistance(getClosestToOrigin(Curry._1(Coord$Aoc19.CoordSet.toList, getCrossings(a.hd, match.hd)))));
          return ;
        }
        
      })(input);

StackSafeFuture$Aoc19.tap(function (a) {
        if (!a) {
          return ;
        }
        var match = a.tl;
        if (match && !match.tl) {
          console.log("Closest paths", findClosestIntersection(a.hd, match.hd));
          return ;
        }
        
      })(input);

exports.InvalidDirection = InvalidDirection;
exports.$great$great = $great$great;
exports.stringToDirection = stringToDirection;
exports.distance = distance;
exports.pathFromDirection = pathFromDirection;
exports.pathFromDirections = pathFromDirections;
exports.getCrossings = getCrossings;
exports.manhattenDistance = manhattenDistance;
exports.getClosestToOrigin = getClosestToOrigin;
exports.addDistanceToPath = addDistanceToPath;
exports.addDistancesToMap = addDistancesToMap;
exports.findClosestIntersection = findClosestIntersection;
exports.input = input;
/* input Not a pure module */
