// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Intcode$Aoc19 = require("./Intcode.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

var UnknownInput = Caml_exceptions.create("Day13-Aoc19.UnknownInput");

function intToSprite(i) {
  if (i > 4 || i < 0) {
    throw {
          RE_EXN_ID: UnknownInput,
          _1: i,
          Error: new Error()
        };
  }
  return i;
}

function spriteToDisplay(sprite) {
  switch (sprite) {
    case /* Empty */0 :
        return " ";
    case /* Wall */1 :
        return "|";
    case /* Block */2 :
        return "#";
    case /* HorizontalPaddle */3 :
        return "=";
    case /* Ball */4 :
        return "*";
    
  }
}

var draw = Coord$Aoc19.CoordMap.set;

var make = Coord$Aoc19.CoordMap.make;

var partial_arg = Curry._1(Relude_List.countBy, (function (param) {
        return /* Block */2 === param;
      }));

function countBlocks(param) {
  return Relude_Function.flipCompose(Coord$Aoc19.CoordMap.values, partial_arg, param);
}

var InvalidScreen = Caml_exceptions.create("Day13-Aoc19.Screen.InvalidScreen");

function ballPaddleXs(screen) {
  var bp = Relude_List.partition((function (param) {
          return param[1] === /* Ball */4;
        }), Curry._1(Coord$Aoc19.CoordMap.toList, Curry._2(Coord$Aoc19.CoordMap.filter, (function (param, v) {
                  if (v === /* Ball */4) {
                    return true;
                  } else {
                    return v === /* HorizontalPaddle */3;
                  }
                }), screen)));
  var match = bp[0];
  if (match) {
    if (match.tl) {
      throw {
            RE_EXN_ID: InvalidScreen,
            Error: new Error()
          };
    }
    var match$1 = bp[1];
    if (match$1) {
      if (match$1.tl) {
        throw {
              RE_EXN_ID: InvalidScreen,
              Error: new Error()
            };
      }
      return [
              match.hd[0][0],
              match$1.hd[0][0]
            ];
    }
    throw {
          RE_EXN_ID: InvalidScreen,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: InvalidScreen,
        Error: new Error()
      };
}

function output(param) {
  return Coord$Aoc19.output(spriteToDisplay, /* Empty */0, param);
}

var $$Screen = {
  draw: draw,
  make: make,
  countBlocks: countBlocks,
  InvalidScreen: InvalidScreen,
  ballPaddleXs: ballPaddleXs,
  output: output
};

function runGame(quarters, input) {
  var input_0 = String(quarters);
  var input_1 = Relude_List.tailOrEmpty(input);
  var input$1 = {
    hd: input_0,
    tl: input_1
  };
  var score = {
    contents: 0
  };
  var screen = {
    contents: Curry._1(make, undefined)
  };
  var outputMode = {
    contents: /* X */0
  };
  var nextOutput = function (string) {
    var v = Caml_format.caml_int_of_string(string);
    var x = outputMode.contents;
    if (typeof x === "number") {
      outputMode.contents = {
        TAG: /* Y */0,
        _0: v
      };
      return ;
    }
    if (!x.TAG) {
      outputMode.contents = {
        TAG: /* SpriteOrScore */1,
        _0: x._0,
        _1: v
      };
      return ;
    }
    var x$1 = x._0;
    if (x$1 === -1 && x._1 === 0) {
      score.contents = v;
      outputMode.contents = /* X */0;
      return ;
    }
    var sprite = intToSprite(v);
    var screenUpdate = Curry._3(draw, [
          x$1,
          x._1
        ], sprite, screen.contents);
    screen.contents = screenUpdate;
    outputMode.contents = /* X */0;
    
  };
  var nextInput = function (param) {
    var match = ballPaddleXs(screen.contents);
    var match$1 = Curry._2(Relude_Int.compare, match[0], match[1]);
    return StackSafeFuture$Aoc19.pure(match$1 === "greater_than" ? "1" : (
                  match$1 === "less_than" ? "-1" : "0"
                ));
  };
  return StackSafeFuture$Aoc19.map((function (param) {
                return [
                        screen.contents,
                        score.contents
                      ];
              }), Intcode$Aoc19.run(nextInput, nextOutput, input$1));
}

var Cabinet = {
  runGame: runGame
};

var input = InputLoader$Aoc19.commaSeparated(13);

StackSafeFuture$Aoc19.tap(function (param) {
        return Relude_Function.flipCompose(countBlocks, (function (param) {
                      console.log("Block count", param);
                      
                    }), param);
      })(StackSafeFuture$Aoc19.map((function (param) {
            return param[0];
          }), Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                return runGame(1, param);
              }), input)));

StackSafeFuture$Aoc19.tap(function (param) {
        console.log("Score", param);
        
      })(StackSafeFuture$Aoc19.map((function (param) {
            return param[1];
          }), Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                return runGame(2, param);
              }), input)));

var CoordMap;

var $great$great = Relude_Function.flipCompose;

exports.CoordMap = CoordMap;
exports.$great$great = $great$great;
exports.UnknownInput = UnknownInput;
exports.intToSprite = intToSprite;
exports.spriteToDisplay = spriteToDisplay;
exports.$$Screen = $$Screen;
exports.Cabinet = Cabinet;
exports.input = input;
/* partial_arg Not a pure module */
