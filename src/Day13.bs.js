// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Intcode$Aoc19 = require("./Intcode.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

var UnknownInput = Caml_exceptions.create("Day13-Aoc19.UnknownInput");

function intToSprite(i) {
  if (i > 4 || i < 0) {
    throw [
          UnknownInput,
          i
        ];
  }
  return i;
}

function spriteToDisplay(sprite) {
  switch (sprite) {
    case /* Empty */0 :
        return " ";
    case /* Wall */1 :
        return "|";
    case /* Block */2 :
        return "#";
    case /* HorizontalPaddle */3 :
        return "=";
    case /* Ball */4 :
        return "*";
    
  }
}

var draw = Coord$Aoc19.CoordMap.set;

var make = Coord$Aoc19.CoordMap.make;

var partial_arg = Curry._1(Relude_List.countBy, (function (param) {
        return Caml_obj.caml_equal(/* Block */2, param);
      }));

var partial_arg$1 = Coord$Aoc19.CoordMap.values;

function countBlocks(param) {
  return Relude_Function.flipCompose(partial_arg$1, partial_arg, param);
}

var InvalidScreen = Caml_exceptions.create("Day13-Aoc19.Screen.InvalidScreen");

function ballPaddleXs(screen) {
  var bp = Relude_List.partition((function (param) {
          return param[1] === /* Ball */4;
        }), Curry._1(Coord$Aoc19.CoordMap.toList, Curry._2(Coord$Aoc19.CoordMap.filter, (function (param, v) {
                  if (v === /* Ball */4) {
                    return true;
                  } else {
                    return v === /* HorizontalPaddle */3;
                  }
                }), screen)));
  var match = bp[0];
  if (match) {
    if (match[1]) {
      throw InvalidScreen;
    }
    var match$1 = bp[1];
    if (match$1) {
      if (match$1[1]) {
        throw InvalidScreen;
      }
      return /* tuple */[
              match[0][0][0],
              match$1[0][0][0]
            ];
    } else {
      throw InvalidScreen;
    }
  } else {
    throw InvalidScreen;
  }
}

function output(param) {
  return Coord$Aoc19.output(spriteToDisplay, /* Empty */0, param);
}

var $$Screen = {
  draw: draw,
  make: make,
  countBlocks: countBlocks,
  InvalidScreen: InvalidScreen,
  ballPaddleXs: ballPaddleXs,
  output: output
};

function runGame(quarters, input) {
  var input_000 = String(quarters);
  var input_001 = Relude_List.tailOrEmpty(input);
  var input$1 = /* :: */[
    input_000,
    input_001
  ];
  var score = /* record */[/* contents */0];
  var screen = /* record */[/* contents */Curry._1(make, /* () */0)];
  var outputMode = /* record */[/* contents : X */0];
  var nextOutput = function (string) {
    var v = Caml_format.caml_int_of_string(string);
    var match = outputMode[0];
    if (typeof match === "number") {
      outputMode[0] = /* Y */Block.__(0, [v]);
      return /* () */0;
    } else if (match.tag) {
      var x = match[0];
      if (x === -1 && match[1] === 0) {
        score[0] = v;
        outputMode[0] = /* X */0;
        return /* () */0;
      }
      var sprite = intToSprite(v);
      var screenUpdate = Curry._3(draw, /* tuple */[
            x,
            match[1]
          ], sprite, screen[0]);
      screen[0] = screenUpdate;
      outputMode[0] = /* X */0;
      return /* () */0;
    } else {
      outputMode[0] = /* SpriteOrScore */Block.__(1, [
          match[0],
          v
        ]);
      return /* () */0;
    }
  };
  var nextInput = function (param) {
    var match = ballPaddleXs(screen[0]);
    var match$1 = Curry._2(Relude_Int.compare, match[0], match[1]);
    return StackSafeFuture$Aoc19.pure(match$1 !== 159039494 ? (
                  match$1 >= 939214151 ? "-1" : "0"
                ) : "1");
  };
  return StackSafeFuture$Aoc19.map((function (param) {
                return /* tuple */[
                        screen[0],
                        score[0]
                      ];
              }), Intcode$Aoc19.run(nextInput, nextOutput, input$1));
}

var Cabinet = {
  runGame: runGame
};

var input = InputLoader$Aoc19.commaSeparated(13);

StackSafeFuture$Aoc19.tap((function (param) {
          return Relude_Function.flipCompose(countBlocks, (function (param) {
                        console.log("Block count", param);
                        return /* () */0;
                      }), param);
        }))(StackSafeFuture$Aoc19.map((function (param) {
            return param[0];
          }), Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                return runGame(1, param);
              }), input)));

StackSafeFuture$Aoc19.tap((function (param) {
          console.log("Score", param);
          return /* () */0;
        }))(StackSafeFuture$Aoc19.map((function (param) {
            return param[1];
          }), Curry._2(StackSafeFuture$Aoc19.flatMap, (function (param) {
                return runGame(2, param);
              }), input)));

var CoordMap = 0;

var $great$great = Relude_Function.flipCompose;

exports.CoordMap = CoordMap;
exports.$great$great = $great$great;
exports.UnknownInput = UnknownInput;
exports.intToSprite = intToSprite;
exports.spriteToDisplay = spriteToDisplay;
exports.$$Screen = $$Screen;
exports.Cabinet = Cabinet;
exports.input = input;
/* partial_arg Not a pure module */
