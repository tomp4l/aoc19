// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Relude_Extensions_Apply = require("relude/src/extensions/Relude_Extensions_Apply.bs.js");
var Relude_Extensions_Monad = require("relude/src/extensions/Relude_Extensions_Monad.bs.js");
var Relude_Extensions_Functor = require("relude/src/extensions/Relude_Extensions_Functor.bs.js");
var Relude_Extensions_Applicative = require("relude/src/extensions/Relude_Extensions_Applicative.bs.js");

function more(thunk) {
  return {
          TAG: /* More */1,
          _0: thunk
        };
}

function flatMap(f, trampoline) {
  switch (trampoline.TAG | 0) {
    case /* Done */0 :
    case /* More */1 :
        return {
                TAG: /* FlatMap */2,
                _0: trampoline,
                _1: f
              };
    case /* FlatMap */2 :
        var cont = trampoline._1;
        return {
                TAG: /* FlatMap */2,
                _0: trampoline._0,
                _1: (function (x) {
                    return flatMap(f, Curry._1(cont, x));
                  })
              };
    
  }
}

function resume(_trampoline) {
  while(true) {
    var trampoline = _trampoline;
    switch (trampoline.TAG | 0) {
      case /* Done */0 :
          return {
                  TAG: /* Right */1,
                  _0: trampoline._0
                };
      case /* More */1 :
          return {
                  TAG: /* Left */0,
                  _0: trampoline._0
                };
      case /* FlatMap */2 :
          var v = trampoline._0;
          switch (v.TAG | 0) {
            case /* Done */0 :
                _trampoline = Curry._1(trampoline._1, v._0);
                continue ;
            case /* More */1 :
                var cont = trampoline._1;
                var t = v._0;
                return {
                        TAG: /* Left */0,
                        _0: (function(t,cont){
                        return function (param) {
                          return {
                                  TAG: /* FlatMap */2,
                                  _0: Curry._1(t, undefined),
                                  _1: cont
                                };
                        }
                        }(t,cont))
                      };
            case /* FlatMap */2 :
                var cont$1 = trampoline._1;
                var cont$prime = v._1;
                _trampoline = flatMap((function(cont$prime,cont$1){
                    return function (x) {
                      return flatMap(cont$1, Curry._1(cont$prime, x));
                    }
                    }(cont$prime,cont$1)), v._0);
                continue ;
            
          }
      
    }
  };
}

function run(_trampoline) {
  while(true) {
    var trampoline = _trampoline;
    var v = resume(trampoline);
    if (v.TAG !== /* Left */0) {
      return v._0;
    }
    _trampoline = Curry._1(v._0, undefined);
    continue ;
  };
}

function map(f) {
  return function (param) {
    return flatMap((function (v) {
                  return {
                          TAG: /* Done */0,
                          _0: Curry._1(f, v)
                        };
                }), param);
  };
}

var Functor = {
  map: map
};

var include = Relude_Extensions_Functor.FunctorExtensions(Functor);

function apply(f, a) {
  return flatMap((function (f) {
                return map(Curry.__1(f))(a);
              }), f);
}

var Apply = {
  map: map,
  apply: apply
};

var include$1 = Relude_Extensions_Apply.ApplyExtensions(Apply);

function pure(v) {
  return {
          TAG: /* Done */0,
          _0: v
        };
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

var include$2 = Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

function bind(x, f) {
  return flatMap(f, x);
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: bind
};

var include$3 = Relude_Extensions_Monad.MonadExtensions(Monad);

var BsFunctorExtensions = include.BsFunctorExtensions;

var flipMap = include.flipMap;

var $$void = include.$$void;

var voidRight = include.voidRight;

var voidLeft = include.voidLeft;

var flap = include.flap;

var BsApplyExtensions = include$1.BsApplyExtensions;

var applyFirst = include$1.applyFirst;

var applySecond = include$1.applySecond;

var map2 = include$1.map2;

var map3 = include$1.map3;

var map4 = include$1.map4;

var map5 = include$1.map5;

var tuple2 = include$1.tuple2;

var tuple3 = include$1.tuple3;

var tuple4 = include$1.tuple4;

var tuple5 = include$1.tuple5;

var mapTuple2 = include$1.mapTuple2;

var mapTuple3 = include$1.mapTuple3;

var mapTuple4 = include$1.mapTuple4;

var mapTuple5 = include$1.mapTuple5;

var BsApplicativeExtensions = include$2.BsApplicativeExtensions;

var liftA1 = include$2.liftA1;

var all = include$2.all;

var BsMonadExtensions = include$3.BsMonadExtensions;

var flatMap$1 = include$3.flatMap;

var flatten = include$3.flatten;

var composeKleisli = include$3.composeKleisli;

var flipComposeKleisli = include$3.flipComposeKleisli;

var liftM1 = include$3.liftM1;

var when_ = include$3.when_;

var unless = include$3.unless;

exports.more = more;
exports.resume = resume;
exports.run = run;
exports.map = map;
exports.Functor = Functor;
exports.BsFunctorExtensions = BsFunctorExtensions;
exports.flipMap = flipMap;
exports.$$void = $$void;
exports.voidRight = voidRight;
exports.voidLeft = voidLeft;
exports.flap = flap;
exports.apply = apply;
exports.Apply = Apply;
exports.BsApplyExtensions = BsApplyExtensions;
exports.applyFirst = applyFirst;
exports.applySecond = applySecond;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.mapTuple2 = mapTuple2;
exports.mapTuple3 = mapTuple3;
exports.mapTuple4 = mapTuple4;
exports.mapTuple5 = mapTuple5;
exports.pure = pure;
exports.Applicative = Applicative;
exports.BsApplicativeExtensions = BsApplicativeExtensions;
exports.liftA1 = liftA1;
exports.all = all;
exports.bind = bind;
exports.Monad = Monad;
exports.BsMonadExtensions = BsMonadExtensions;
exports.flatMap = flatMap$1;
exports.flatten = flatten;
exports.composeKleisli = composeKleisli;
exports.flipComposeKleisli = flipComposeKleisli;
exports.liftM1 = liftM1;
exports.when_ = when_;
exports.unless = unless;
/* include Not a pure module */
