// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Relude_Extensions_Apply = require("relude/src/extensions/Relude_Extensions_Apply.bs.js");
var Relude_Extensions_Monad = require("relude/src/extensions/Relude_Extensions_Monad.bs.js");
var Relude_Extensions_Functor = require("relude/src/extensions/Relude_Extensions_Functor.bs.js");
var Relude_Extensions_Applicative = require("relude/src/extensions/Relude_Extensions_Applicative.bs.js");

function more(thunk) {
  return /* More */Block.__(1, [thunk]);
}

function flatMap(f, trampoline) {
  switch (trampoline.tag | 0) {
    case /* Done */0 :
    case /* More */1 :
        return /* FlatMap */Block.__(2, [
                  trampoline,
                  f
                ]);
    case /* FlatMap */2 :
        var cont = trampoline[1];
        return /* FlatMap */Block.__(2, [
                  trampoline[0],
                  (function (x) {
                      return flatMap(f, Curry._1(cont, x));
                    })
                ]);
    
  }
}

function resume(_trampoline) {
  while(true) {
    var trampoline = _trampoline;
    switch (trampoline.tag | 0) {
      case /* Done */0 :
          return /* Right */Block.__(1, [trampoline[0]]);
      case /* More */1 :
          return /* Left */Block.__(0, [trampoline[0]]);
      case /* FlatMap */2 :
          var match = trampoline[0];
          switch (match.tag | 0) {
            case /* Done */0 :
                _trampoline = Curry._1(trampoline[1], match[0]);
                continue ;
            case /* More */1 :
                var cont = trampoline[1];
                var t = match[0];
                return /* Left */Block.__(0, [(function(t,cont){
                          return function (param) {
                            return /* FlatMap */Block.__(2, [
                                      Curry._1(t, /* () */0),
                                      cont
                                    ]);
                          }
                          }(t,cont))]);
            case /* FlatMap */2 :
                var cont$1 = trampoline[1];
                var cont$prime = match[1];
                _trampoline = flatMap((function(cont$prime,cont$1){
                    return function (x) {
                      return flatMap(cont$1, Curry._1(cont$prime, x));
                    }
                    }(cont$prime,cont$1)), match[0]);
                continue ;
            
          }
      
    }
  };
}

function run(_trampoline) {
  while(true) {
    var trampoline = _trampoline;
    var match = resume(trampoline);
    if (match.tag) {
      return match[0];
    } else {
      _trampoline = Curry._1(match[0], /* () */0);
      continue ;
    }
  };
}

function map(f) {
  return (function (param) {
      return flatMap((function (v) {
                    return /* Done */Block.__(0, [Curry._1(f, v)]);
                  }), param);
    });
}

var Functor = {
  map: map
};

var include = Relude_Extensions_Functor.FunctorExtensions(Functor);

function apply(f, a) {
  return flatMap((function (f) {
                return map(Curry.__1(f))(a);
              }), f);
}

var Apply = {
  map: map,
  apply: apply
};

var include$1 = Relude_Extensions_Apply.ApplyExtensions(Apply);

function pure(v) {
  return /* Done */Block.__(0, [v]);
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

var include$2 = Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

function bind(x, f) {
  return flatMap(f, x);
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: bind
};

var include$3 = Relude_Extensions_Monad.MonadExtensions(Monad);

var BsFunctorExtensions = include.BsFunctorExtensions;

var flipMap = include.flipMap;

var $$void = include.$$void;

var voidRight = include.voidRight;

var voidLeft = include.voidLeft;

var flap = include.flap;

var BsApplyExtensions = include$1.BsApplyExtensions;

var applyFirst = include$1.applyFirst;

var applySecond = include$1.applySecond;

var map2 = include$1.map2;

var map3 = include$1.map3;

var map4 = include$1.map4;

var map5 = include$1.map5;

var tuple2 = include$1.tuple2;

var tuple3 = include$1.tuple3;

var tuple4 = include$1.tuple4;

var tuple5 = include$1.tuple5;

var mapTuple2 = include$1.mapTuple2;

var mapTuple3 = include$1.mapTuple3;

var mapTuple4 = include$1.mapTuple4;

var mapTuple5 = include$1.mapTuple5;

var BsApplicativeExtensions = include$2.BsApplicativeExtensions;

var liftA1 = include$2.liftA1;

var all = include$2.all;

var BsMonadExtensions = include$3.BsMonadExtensions;

var flatMap$1 = include$3.flatMap;

var flatten = include$3.flatten;

var composeKleisli = include$3.composeKleisli;

var flipComposeKleisli = include$3.flipComposeKleisli;

var liftM1 = include$3.liftM1;

var when_ = include$3.when_;

var unless = include$3.unless;

exports.more = more;
exports.resume = resume;
exports.run = run;
exports.map = map;
exports.Functor = Functor;
exports.BsFunctorExtensions = BsFunctorExtensions;
exports.flipMap = flipMap;
exports.$$void = $$void;
exports.voidRight = voidRight;
exports.voidLeft = voidLeft;
exports.flap = flap;
exports.apply = apply;
exports.Apply = Apply;
exports.BsApplyExtensions = BsApplyExtensions;
exports.applyFirst = applyFirst;
exports.applySecond = applySecond;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.mapTuple2 = mapTuple2;
exports.mapTuple3 = mapTuple3;
exports.mapTuple4 = mapTuple4;
exports.mapTuple5 = mapTuple5;
exports.pure = pure;
exports.Applicative = Applicative;
exports.BsApplicativeExtensions = BsApplicativeExtensions;
exports.liftA1 = liftA1;
exports.all = all;
exports.bind = bind;
exports.Monad = Monad;
exports.BsMonadExtensions = BsMonadExtensions;
exports.flatMap = flatMap$1;
exports.flatten = flatten;
exports.composeKleisli = composeKleisli;
exports.flipComposeKleisli = flipComposeKleisli;
exports.liftM1 = liftM1;
exports.when_ = when_;
exports.unless = unless;
/* include Not a pure module */
