// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Relude_Map = require("relude/src/Relude_Map.bs.js");
var Relude_Set = require("relude/src/Relude_Set.bs.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var Relude_StringMap = require("relude/src/Relude_StringMap.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

function compare(a, b) {
  switch (a.TAG | 0) {
    case /* Start */0 :
        switch (b.TAG | 0) {
          case /* Start */0 :
              return Curry._2(Relude_Int.Ord.compare, a._0, b._0);
          case /* Key */1 :
          case /* Door */2 :
              return "greater_than";
          
        }
    case /* Key */1 :
        switch (b.TAG | 0) {
          case /* Key */1 :
              return Curry._2(Relude_String.Ord.compare, a._0, b._0);
          case /* Start */0 :
          case /* Door */2 :
              return "less_than";
          
        }
    case /* Door */2 :
        switch (b.TAG | 0) {
          case /* Start */0 :
              return "less_than";
          case /* Key */1 :
              return "greater_than";
          case /* Door */2 :
              return Curry._2(Relude_String.Ord.compare, a._0, b._0);
          
        }
    
  }
}

function eq(a, b) {
  return compare(a, b) === "equal_to";
}

var PointOfInterestOrd = {
  eq: eq,
  compare: compare
};

var PointOfInterestMap = Relude_Map.WithOrd(PointOfInterestOrd);

var PointOfInterestSet = Relude_Set.WithOrd(PointOfInterestOrd);

function sToT(s) {
  return (1 << (Caml_string.get(s, 0) - /* "a" */97 | 0));
}

function add(s, t) {
  return t | sToT(s);
}

function contains(s, t) {
  return (t & sToT(s)) !== 0;
}

function length(x) {
  if (x === 0) {
    return 0;
  } else {
    return (1 & x) + length((x >>> 1)) | 0;
  }
}

function fromList(xs) {
  return Relude_List.foldLeft((function (acc, x) {
                  return acc | sToT(x);
                }), 0)(xs);
}

function compare$1(a, b) {
  return Curry._2(Relude_Int.compare, a, b);
}

var KeySet = {
  sToT: sToT,
  add: add,
  empty: 0,
  contains: contains,
  length: length,
  fromList: fromList,
  compare: compare$1
};

function compare$2(a, b) {
  var compareDistance = Curry._2(Relude_Int.Ord.compare, a.distance, b.distance);
  if (compareDistance === "equal_to") {
    return compare(a.point, b.point);
  } else {
    return compareDistance;
  }
}

function eq$1(a, b) {
  return compare$2(a, b) === "equal_to";
}

var Ord = {
  eq: eq$1,
  compare: compare$2
};

var $$Set = Relude_Set.WithOrd(Ord);

var PointWithDistance = {
  Ord: Ord,
  $$Set: $$Set
};

function compare$3(a, b) {
  var compareKey = compare(a.point, b.point);
  if (compareKey === "equal_to") {
    return Curry._2(Relude_Int.compare, a.collectedKeys, b.collectedKeys);
  } else {
    return compareKey;
  }
}

function eq$2(a, b) {
  return compare$3(a, b) === "equal_to";
}

var Ord$1 = {
  eq: eq$2,
  compare: compare$3
};

var $$Map = Relude_Map.WithOrd(Ord$1);

var PointWithCollectedKeys = {
  Ord: Ord$1,
  $$Map: $$Map
};

function comparePointOfIntestSet(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    var match = Curry._1(PointOfInterestSet.maximum, a);
    var match$1 = Curry._1(PointOfInterestSet.maximum, b);
    if (match === undefined) {
      if (match$1 !== undefined) {
        return "less_than";
      } else {
        return "equal_to";
      }
    }
    if (match$1 === undefined) {
      return "greater_than";
    }
    var c = compare(match, match$1);
    if (c !== "equal_to") {
      return c;
    }
    _b = Curry._2(PointOfInterestSet.remove, match$1, b);
    _a = Curry._2(PointOfInterestSet.remove, match, a);
    continue ;
  };
}

function compare$4(a, b) {
  var compareDistance = Curry._2(Relude_Int.Ord.compare, a.distance, b.distance);
  if (compareDistance !== "equal_to") {
    return compareDistance;
  }
  var compareKey = comparePointOfIntestSet(a.points, b.points);
  if (compareKey === "equal_to") {
    return Curry._2(Relude_Int.compare, a.collectedKeys, b.collectedKeys);
  } else {
    return compareKey;
  }
}

function eq$3(a, b) {
  return compare$4(a, b) === "equal_to";
}

var Ord$2 = {
  eq: eq$3,
  compare: compare$4
};

var $$Set$1 = Relude_Set.WithOrd(Ord$2);

var $$Map$1 = Relude_Map.WithOrd(Ord$2);

var CollectionState = {
  comparePointOfIntestSet: comparePointOfIntestSet,
  Ord: Ord$2,
  $$Set: $$Set$1,
  $$Map: $$Map$1
};

var UnknownCell = Caml_exceptions.create("Day18-Aoc19.Maze.UnknownCell");

function charToCell(c) {
  switch (c) {
    case "#" :
        return /* Wall */0;
    case "." :
        return /* Floor */1;
    case "@" :
        return /* PointOfInterest */{
                _0: {
                  TAG: /* Start */0,
                  _0: 0
                }
              };
    default:
      if (Relude_String.toUpperCase(c) === c) {
        return /* PointOfInterest */{
                _0: {
                  TAG: /* Door */2,
                  _0: Relude_String.toLowerCase(c)
                }
              };
      }
      if (Relude_String.toLowerCase(c) === c) {
        return /* PointOfInterest */{
                _0: {
                  TAG: /* Key */1,
                  _0: c
                }
              };
      }
      throw {
            RE_EXN_ID: UnknownCell,
            _1: c,
            Error: new Error()
          };
  }
}

function mapToGraph(map) {
  var emptyGraph = Curry._1(PointOfInterestMap.make, undefined);
  var neighbours = function (param) {
    var y = param[1];
    var x = param[0];
    return {
            hd: [
              x,
              y + 1 | 0
            ],
            tl: {
              hd: [
                x,
                y - 1 | 0
              ],
              tl: {
                hd: [
                  x + 1 | 0,
                  y
                ],
                tl: {
                  hd: [
                    x - 1 | 0,
                    y
                  ],
                  tl: /* [] */0
                }
              }
            }
          };
  };
  var pointsFromPoint = function (point) {
    var asCell = /* PointOfInterest */{
      _0: point
    };
    var match = Relude_Option.getOrThrow(Curry._2(Coord$Aoc19.CoordMap.find, (function (param, c) {
                return Caml_obj.caml_equal(c, asCell);
              }), map));
    var _toVisit = {
      hd: [
        match[0],
        0
      ],
      tl: /* [] */0
    };
    var _visited = Coord$Aoc19.CoordSet.empty;
    var _acc = Curry._1(PointOfInterestMap.make, undefined);
    while(true) {
      var acc = _acc;
      var visited = _visited;
      var toVisit = _toVisit;
      if (!toVisit) {
        return acc;
      }
      var toVisit$1 = toVisit.tl;
      var match$1 = toVisit.hd;
      var distance = match$1[1];
      var p = match$1[0];
      if (Curry._2(Coord$Aoc19.CoordSet.contains, p, visited)) {
        _toVisit = toVisit$1;
        continue ;
      }
      var newNeighbours = Relude_List.map((function(distance){
            return function (p) {
              return [
                      p,
                      distance + 1 | 0
                    ];
            }
            }(distance)))(Relude_List.filterNot((function(visited){
                return function (v) {
                  return Curry._2(Coord$Aoc19.CoordSet.contains, v, visited);
                }
                }(visited)))(neighbours(p)));
      var newVisited = Curry._2(Coord$Aoc19.CoordSet.add, p, visited);
      var newToVisit = Relude_List.concat(toVisit$1, newNeighbours);
      var match$2 = Curry._2(Coord$Aoc19.CoordMap.get, p, map);
      if (match$2 !== undefined) {
        if (typeof match$2 === "number") {
          if (match$2 !== 0) {
            _visited = newVisited;
            _toVisit = newToVisit;
            continue ;
          }
          _visited = newVisited;
          continue ;
        }
        if (distance === 0) {
          _visited = newVisited;
          _toVisit = newToVisit;
          continue ;
        }
        _acc = Curry._3(PointOfInterestMap.set, match$2._0, distance, acc);
        _visited = newVisited;
        continue ;
      }
      _visited = newVisited;
      continue ;
    };
  };
  return Relude_List.foldLeft((function (g, p) {
                  return Curry._3(PointOfInterestMap.set, p, pointsFromPoint(p), g);
                }), emptyGraph)(Relude_List.mapOption((function (a) {
                    if (typeof a === "number") {
                      return ;
                    } else {
                      return a._0;
                    }
                  }), Curry._1(Coord$Aoc19.CoordMap.values, map)));
}

function fromString(string, hasFourRobots) {
  var partial_arg = Relude_List.map(charToCell);
  var coords = Curry._1(Coord$Aoc19.CoordMap.fromList, Coord$Aoc19.addCoordinates(Relude_List.map(function (param) {
                  return Relude_Function.flipCompose((function (param) {
                                return Relude_String.splitAsList("", param);
                              }), partial_arg, param);
                })(Relude_String.splitAsList("\n", string))));
  var tmp;
  if (hasFourRobots) {
    var match = Relude_Option.getOrThrow(Curry._2(Coord$Aoc19.CoordMap.find, (function (param, c) {
                return Caml_obj.caml_equal(c, /* PointOfInterest */{
                            _0: {
                              TAG: /* Start */0,
                              _0: 0
                            }
                          });
              }), coords));
    var match$1 = match[0];
    var y = match$1[1];
    var x = match$1[0];
    tmp = Curry._2(Coord$Aoc19.CoordMap.mergeMany, Relude_List.toArray({
              hd: [
                [
                  x,
                  y
                ],
                /* Wall */0
              ],
              tl: {
                hd: [
                  [
                    x + 1 | 0,
                    y
                  ],
                  /* Wall */0
                ],
                tl: {
                  hd: [
                    [
                      x - 1 | 0,
                      y
                    ],
                    /* Wall */0
                  ],
                  tl: {
                    hd: [
                      [
                        x,
                        y + 1 | 0
                      ],
                      /* Wall */0
                    ],
                    tl: {
                      hd: [
                        [
                          x,
                          y - 1 | 0
                        ],
                        /* Wall */0
                      ],
                      tl: {
                        hd: [
                          [
                            x - 1 | 0,
                            y - 1 | 0
                          ],
                          /* PointOfInterest */{
                            _0: {
                              TAG: /* Start */0,
                              _0: 1
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            [
                              x + 1 | 0,
                              y - 1 | 0
                            ],
                            /* PointOfInterest */{
                              _0: {
                                TAG: /* Start */0,
                                _0: 2
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              [
                                x - 1 | 0,
                                y + 1 | 0
                              ],
                              /* PointOfInterest */{
                                _0: {
                                  TAG: /* Start */0,
                                  _0: 3
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                [
                                  x + 1 | 0,
                                  y + 1 | 0
                                ],
                                /* PointOfInterest */{
                                  _0: {
                                    TAG: /* Start */0,
                                    _0: 4
                                  }
                                }
                              ],
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }), coords);
  } else {
    tmp = coords;
  }
  return mapToGraph(tmp);
}

function nextKeys$prime(map, collectedKeys, _distances, _pointsNotVisited, _keys) {
  while(true) {
    var keys = _keys;
    var pointsNotVisited = _pointsNotVisited;
    var distances = _distances;
    var filterNotReachedKeysOrLockedDoors = Curry._1(PointOfInterestMap.filterNot, (function(keys){
        return function (p, param) {
          switch (p.TAG | 0) {
            case /* Start */0 :
                return false;
            case /* Key */1 :
                return Curry._2(Relude_StringMap.contains, p._0, keys);
            case /* Door */2 :
                return !contains(p._0, collectedKeys);
            
          }
        }
        }(keys)));
    var closest = Curry._1($$Set.minimum, Curry._2($$Set.filter, (function(pointsNotVisited){
            return function (param) {
              return Curry._2(PointOfInterestSet.contains, param.point, pointsNotVisited);
            }
            }(pointsNotVisited)), distances));
    if (closest === undefined) {
      return keys;
    }
    var reachable = Relude_List.map((function(closest){
          return function (param) {
            return {
                    point: param[0],
                    distance: closest.distance + param[1] | 0
                  };
          }
          }(closest)))(Curry._1(PointOfInterestMap.toList, Curry._1(filterNotReachedKeysOrLockedDoors, Curry._3(PointOfInterestMap.getOrElse, closest.point, Curry._1(PointOfInterestMap.make, undefined), map))));
    var match = Relude_List.partition((function (pd) {
            var k = pd.point;
            switch (k.TAG | 0) {
              case /* Key */1 :
                  return !contains(k._0, collectedKeys);
              case /* Start */0 :
              case /* Door */2 :
                  return false;
              
            }
          }), reachable);
    var closerNotToCollect = Relude_List.filter((function(distances){
        return function (param) {
          var distance = param.distance;
          var point = param.point;
          return Relude_Option.getOrElse(true, Relude_Option.map((function (param) {
                            return param.distance > distance;
                          }), Curry._1($$Set.maximum, Curry._2($$Set.filter, (function (param) {
                                    return Caml_obj.caml_equal(point, param.point);
                                  }), distances))));
        }
        }(distances)), match[1]);
    var nextKeys = Relude_List.foldLeft((function (acc, param) {
              return Curry._3(Relude_StringMap.set, param[0], param[1], acc);
            }), keys)(Relude_List.mapOption((function (param) {
                var k = param.point;
                switch (k.TAG | 0) {
                  case /* Key */1 :
                      return [
                              k._0,
                              param.distance
                            ];
                  case /* Start */0 :
                  case /* Door */2 :
                      return ;
                  
                }
              }), match[0]));
    var nextDistances = Relude_List.foldLeft((function (acc, pwd) {
              var removed = Relude_Option.getOrElse(acc, Relude_Option.map((function (p) {
                          return Curry._2($$Set.remove, p, acc);
                        }), Curry._1($$Set.maximum, Curry._2($$Set.filter, (function (param) {
                                  return Caml_obj.caml_equal(param.point, pwd.point);
                                }), acc))));
              return Curry._2($$Set.add, pwd, removed);
            }), distances)(closerNotToCollect);
    var nextPointsNotVisited = Relude_List.foldLeft((function (acc, param) {
              return Curry._2(PointOfInterestSet.add, param.point, acc);
            }), Curry._2(PointOfInterestSet.remove, closest.point, pointsNotVisited))(closerNotToCollect);
    _keys = nextKeys;
    _pointsNotVisited = nextPointsNotVisited;
    _distances = nextDistances;
    continue ;
  };
}

function nextKeys(collectedKeys, current, map) {
  return Relude_List.sortBy((function (param, param$1) {
                return Curry._2(Relude_Int.Ord.compare, param[1], param$1[1]);
              }), Curry._1(Relude_StringMap.toList, nextKeys$prime(map, collectedKeys, Curry._1($$Set.fromList, {
                          hd: {
                            point: current,
                            distance: 0
                          },
                          tl: /* [] */0
                        }), Curry._1(PointOfInterestSet.fromList, {
                          hd: current,
                          tl: /* [] */0
                        }), Curry._1(Relude_StringMap.make, undefined))));
}

function numberOfKeys(map) {
  return Curry._3(PointOfInterestMap.foldLeft, (function (c, k, param) {
                switch (k.TAG | 0) {
                  case /* Key */1 :
                      return c + 1 | 0;
                  case /* Start */0 :
                  case /* Door */2 :
                      return c;
                  
                }
              }), 0, map);
}

function collectKeysFromPoints(_pointsFrom, closest, _newStates, nextKeys) {
  while(true) {
    var newStates = _newStates;
    var pointsFrom = _pointsFrom;
    var point = Curry._1(PointOfInterestSet.minimum, pointsFrom);
    if (point === undefined) {
      return newStates;
    }
    var collectedKeys = closest.collectedKeys;
    var distance = closest.distance;
    var points = closest.points;
    var keys = Curry._2(nextKeys, collectedKeys, point);
    var newStates$prime = Relude_List.map((function(points,distance,collectedKeys,point){
          return function (param) {
            var k = param[0];
            return {
                    points: Curry._2(PointOfInterestSet.add, {
                          TAG: /* Key */1,
                          _0: k
                        }, Curry._2(PointOfInterestSet.remove, point, points)),
                    distance: distance + param[1] | 0,
                    collectedKeys: collectedKeys | sToT(k)
                  };
          }
          }(points,distance,collectedKeys,point)))(keys);
    _newStates = Relude_List.concat(newStates, newStates$prime);
    _pointsFrom = Curry._2(PointOfInterestSet.remove, point, pointsFrom);
    continue ;
  };
}

function collectAllKeys$prime(targetKeyCount, _ongoingStates, _bestDistances, nextKeys) {
  while(true) {
    var bestDistances = _bestDistances;
    var ongoingStates = _ongoingStates;
    var closest = Relude_Option.getOrThrow(Curry._1($$Set$1.minimum, ongoingStates));
    if (length(closest.collectedKeys) === targetKeyCount) {
      return closest.distance;
    }
    var statesWithoutClosest = Curry._2($$Set$1.remove, closest, ongoingStates);
    var newStates = collectKeysFromPoints(closest.points, closest, /* [] */0, nextKeys);
    var closerStates = Curry._2($$Set$1.filter, (function(bestDistances){
        return function (param) {
          var distance = param.distance;
          return Relude_Option.getOrElse(true, Relude_Option.map((function (d) {
                            return d > distance;
                          }), Curry._2($$Map$1.get, {
                              points: param.points,
                              distance: 0,
                              collectedKeys: param.collectedKeys
                            }, bestDistances)));
        }
        }(bestDistances)), Curry._1($$Set$1.fromList, newStates));
    var newBestDistances = Curry._3($$Set$1.foldLeft, (function (acc, param) {
            return Curry._3($$Map$1.set, {
                        points: param.points,
                        distance: 0,
                        collectedKeys: param.collectedKeys
                      }, param.distance, acc);
          }), bestDistances, closerStates);
    var states = Curry._2($$Set$1.union, statesWithoutClosest, closerStates);
    _bestDistances = newBestDistances;
    _ongoingStates = states;
    continue ;
  };
}

function nextKeysForMap(map) {
  var cache = {
    contents: Curry._1($$Map.make, undefined)
  };
  return function (collectedKeys, current) {
    var key = {
      point: current,
      collectedKeys: collectedKeys
    };
    var v = Curry._2($$Map.get, key, cache.contents);
    if (v !== undefined) {
      return v;
    }
    var v$1 = nextKeys(collectedKeys, current, map);
    cache.contents = Curry._3($$Map.set, key, v$1, cache.contents);
    return v$1;
  };
}

function collectAllKeys(string) {
  var map = fromString(string, false);
  var targetKeyCount = numberOfKeys(map);
  return collectAllKeys$prime(targetKeyCount, Curry._1($$Set$1.fromList, {
                  hd: {
                    points: Curry._1(PointOfInterestSet.fromList, {
                          hd: {
                            TAG: /* Start */0,
                            _0: 0
                          },
                          tl: /* [] */0
                        }),
                    distance: 0,
                    collectedKeys: 0
                  },
                  tl: /* [] */0
                }), Curry._1($$Map$1.fromList, {
                  hd: [
                    {
                      points: Curry._1(PointOfInterestSet.fromList, {
                            hd: {
                              TAG: /* Start */0,
                              _0: 0
                            },
                            tl: /* [] */0
                          }),
                      distance: 0,
                      collectedKeys: 0
                    },
                    0
                  ],
                  tl: /* [] */0
                }), nextKeysForMap(map));
}

function collectAllKeysFourRobots(string) {
  var map = fromString(string, true);
  var targetKeyCount = numberOfKeys(map);
  return collectAllKeys$prime(targetKeyCount, Curry._1($$Set$1.fromList, {
                  hd: {
                    points: Curry._1(PointOfInterestSet.fromList, {
                          hd: {
                            TAG: /* Start */0,
                            _0: 1
                          },
                          tl: {
                            hd: {
                              TAG: /* Start */0,
                              _0: 2
                            },
                            tl: {
                              hd: {
                                TAG: /* Start */0,
                                _0: 3
                              },
                              tl: {
                                hd: {
                                  TAG: /* Start */0,
                                  _0: 4
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        }),
                    distance: 0,
                    collectedKeys: 0
                  },
                  tl: /* [] */0
                }), Curry._1($$Map$1.fromList, {
                  hd: [
                    {
                      points: Curry._1(PointOfInterestSet.fromList, {
                            hd: {
                              TAG: /* Start */0,
                              _0: 1
                            },
                            tl: {
                              hd: {
                                TAG: /* Start */0,
                                _0: 2
                              },
                              tl: {
                                hd: {
                                  TAG: /* Start */0,
                                  _0: 3
                                },
                                tl: {
                                  hd: {
                                    TAG: /* Start */0,
                                    _0: 4
                                  },
                                  tl: /* [] */0
                                }
                              }
                            }
                          }),
                      distance: 0,
                      collectedKeys: 0
                    },
                    0
                  ],
                  tl: /* [] */0
                }), nextKeysForMap(map));
}

var Maze = {
  UnknownCell: UnknownCell,
  charToCell: charToCell,
  mapToGraph: mapToGraph,
  fromString: fromString,
  nextKeys$prime: nextKeys$prime,
  nextKeys: nextKeys,
  numberOfKeys: numberOfKeys,
  collectKeysFromPoints: collectKeysFromPoints,
  collectAllKeys$prime: collectAllKeys$prime,
  nextKeysForMap: nextKeysForMap,
  collectAllKeys: collectAllKeys,
  collectAllKeysFourRobots: collectAllKeysFourRobots
};

var input = InputLoader$Aoc19.loadDay(18);

StackSafeFuture$Aoc19.tap(function (param) {
        return Relude_Function.flipCompose(collectAllKeys, (function (prim) {
                      console.log(prim);
                      
                    }), param);
      })(input);

StackSafeFuture$Aoc19.tap(function (param) {
        return Relude_Function.flipCompose(collectAllKeysFourRobots, (function (prim) {
                      console.log(prim);
                      
                    }), param);
      })(input);

var $great$great = Relude_Function.flipCompose;

exports.$great$great = $great$great;
exports.PointOfInterestOrd = PointOfInterestOrd;
exports.PointOfInterestMap = PointOfInterestMap;
exports.PointOfInterestSet = PointOfInterestSet;
exports.KeySet = KeySet;
exports.PointWithDistance = PointWithDistance;
exports.PointWithCollectedKeys = PointWithCollectedKeys;
exports.CollectionState = CollectionState;
exports.Maze = Maze;
exports.input = input;
/* PointOfInterestMap Not a pure module */
