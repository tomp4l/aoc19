// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Relude_Int = require("relude/src/Relude_Int.bs.js");
var Relude_Map = require("relude/src/Relude_Map.bs.js");
var Relude_Set = require("relude/src/Relude_Set.bs.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Coord$Aoc19 = require("./lib/Coord.bs.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var Relude_StringMap = require("relude/src/Relude_StringMap.bs.js");
var InputLoader$Aoc19 = require("./lib/InputLoader.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

function compare(a, b) {
  if (typeof a === "number") {
    if (typeof b === "number") {
      return "equal_to";
    } else {
      return "greater_than";
    }
  } else if (a.TAG) {
    if (typeof b === "number") {
      return "less_than";
    } else if (b.TAG) {
      return Curry._2(Relude_String.Ord.compare, a._0, b._0);
    } else {
      return "greater_than";
    }
  } else if (typeof b === "number" || b.TAG) {
    return "less_than";
  } else {
    return Curry._2(Relude_String.Ord.compare, a._0, b._0);
  }
}

function eq(a, b) {
  return compare(a, b) === "equal_to";
}

var PointOfInterestOrd = {
  eq: eq,
  compare: compare
};

var PointOfInterestMap = Relude_Map.WithOrd(PointOfInterestOrd);

var PointOfInterestSet = Relude_Set.WithOrd(PointOfInterestOrd);

function sToT(s) {
  return (1 << (Caml_string.get(s, 0) - /* "a" */97 | 0));
}

function add(s, t) {
  return t | sToT(s);
}

function contains(s, t) {
  return (t & sToT(s)) !== 0;
}

function length(x) {
  if (x === 0) {
    return 0;
  } else {
    return (1 & x) + length((x >>> 1)) | 0;
  }
}

function fromList(xs) {
  return Relude_List.foldLeft((function (acc, x) {
                  return acc | sToT(x);
                }), 0)(xs);
}

function compare$1(a, b) {
  return Curry._2(Relude_Int.compare, a, b);
}

var KeySet = {
  sToT: sToT,
  add: add,
  empty: 0,
  contains: contains,
  length: length,
  fromList: fromList,
  compare: compare$1
};

function compare$2(a, b) {
  var compareDistance = Curry._2(Relude_Int.Ord.compare, a.distance, b.distance);
  if (compareDistance === "equal_to") {
    return compare(a.point, b.point);
  } else {
    return compareDistance;
  }
}

function eq$1(a, b) {
  return compare$2(a, b) === "equal_to";
}

var Ord = {
  eq: eq$1,
  compare: compare$2
};

var $$Set = Relude_Set.WithOrd(Ord);

var PointWithDistance = {
  Ord: Ord,
  $$Set: $$Set
};

function compare$3(a, b) {
  var compareKey = compare(a.point, b.point);
  if (compareKey === "equal_to") {
    return Curry._2(Relude_Int.compare, a.collectedKeys, b.collectedKeys);
  } else {
    return compareKey;
  }
}

function eq$2(a, b) {
  return compare$3(a, b) === "equal_to";
}

var Ord$1 = {
  eq: eq$2,
  compare: compare$3
};

var $$Map = Relude_Map.WithOrd(Ord$1);

var PointWithCollectedKeys = {
  Ord: Ord$1,
  $$Map: $$Map
};

function compare$4(a, b) {
  var compareDistance = Curry._2(Relude_Int.Ord.compare, a.distance, b.distance);
  if (compareDistance !== "equal_to") {
    return compareDistance;
  }
  var compareKey = compare(a.point, b.point);
  if (compareKey === "equal_to") {
    return Curry._2(Relude_Int.compare, a.collectedKeys, b.collectedKeys);
  } else {
    return compareKey;
  }
}

function eq$3(a, b) {
  return compare$4(a, b) === "equal_to";
}

var Ord$2 = {
  eq: eq$3,
  compare: compare$4
};

var $$Set$1 = Relude_Set.WithOrd(Ord$2);

var CollectionState = {
  Ord: Ord$2,
  $$Set: $$Set$1
};

var UnknownCell = Caml_exceptions.create("Day18-Aoc19.Maze.UnknownCell");

function charToCell(c) {
  switch (c) {
    case "#" :
        return /* Wall */0;
    case "." :
        return /* Floor */1;
    case "@" :
        return /* PointOfInterest */{
                _0: /* Start */0
              };
    default:
      if (Relude_String.toUpperCase(c) === c) {
        return /* PointOfInterest */{
                _0: {
                  TAG: /* Door */1,
                  _0: Relude_String.toLowerCase(c)
                }
              };
      }
      if (Relude_String.toLowerCase(c) === c) {
        return /* PointOfInterest */{
                _0: {
                  TAG: /* Key */0,
                  _0: c
                }
              };
      }
      throw {
            RE_EXN_ID: UnknownCell,
            _1: c,
            Error: new Error()
          };
  }
}

function mapToGraph(map) {
  var emptyGraph = Curry._1(PointOfInterestMap.make, undefined);
  var neighbours = function (param) {
    var y = param[1];
    var x = param[0];
    return {
            hd: [
              x,
              y + 1 | 0
            ],
            tl: {
              hd: [
                x,
                y - 1 | 0
              ],
              tl: {
                hd: [
                  x + 1 | 0,
                  y
                ],
                tl: {
                  hd: [
                    x - 1 | 0,
                    y
                  ],
                  tl: /* [] */0
                }
              }
            }
          };
  };
  var pointsFromPoint = function (point) {
    var asCell = /* PointOfInterest */{
      _0: point
    };
    var match = Relude_Option.getOrThrow(Curry._2(Coord$Aoc19.CoordMap.find, (function (param, c) {
                return Caml_obj.caml_equal(c, asCell);
              }), map));
    var _toVisit = {
      hd: [
        match[0],
        0
      ],
      tl: /* [] */0
    };
    var _visited = Coord$Aoc19.CoordSet.empty;
    var _acc = Curry._1(PointOfInterestMap.make, undefined);
    while(true) {
      var acc = _acc;
      var visited = _visited;
      var toVisit = _toVisit;
      if (!toVisit) {
        return acc;
      }
      var toVisit$1 = toVisit.tl;
      var match$1 = toVisit.hd;
      var distance = match$1[1];
      var p = match$1[0];
      if (Curry._2(Coord$Aoc19.CoordSet.contains, p, visited)) {
        _toVisit = toVisit$1;
        continue ;
      }
      var newNeighbours = Relude_List.map((function(distance){
            return function (p) {
              return [
                      p,
                      distance + 1 | 0
                    ];
            }
            }(distance)))(Relude_List.filterNot((function(visited){
                return function (v) {
                  return Curry._2(Coord$Aoc19.CoordSet.contains, v, visited);
                }
                }(visited)))(neighbours(p)));
      var newVisited = Curry._2(Coord$Aoc19.CoordSet.add, p, visited);
      var newToVisit = Relude_List.concat(toVisit$1, newNeighbours);
      var match$2 = Curry._2(Coord$Aoc19.CoordMap.get, p, map);
      if (match$2 !== undefined) {
        if (typeof match$2 === "number") {
          if (match$2 !== 0) {
            _visited = newVisited;
            _toVisit = newToVisit;
            continue ;
          }
          _visited = newVisited;
          continue ;
        }
        if (distance === 0) {
          _visited = newVisited;
          _toVisit = newToVisit;
          continue ;
        }
        _acc = Curry._3(PointOfInterestMap.set, match$2._0, distance, acc);
        _visited = newVisited;
        continue ;
      }
      _visited = newVisited;
      continue ;
    };
  };
  return Relude_List.foldLeft((function (g, p) {
                  return Curry._3(PointOfInterestMap.set, p, pointsFromPoint(p), g);
                }), emptyGraph)(Relude_List.mapOption((function (a) {
                    if (typeof a === "number") {
                      return ;
                    } else {
                      return a._0;
                    }
                  }), Curry._1(Coord$Aoc19.CoordMap.values, map)));
}

function fromString(string) {
  var partial_arg = Relude_List.map(charToCell);
  return mapToGraph(Curry._1(Coord$Aoc19.CoordMap.fromList, Coord$Aoc19.addCoordinates(Relude_List.map(function (param) {
                            return Relude_Function.flipCompose((function (param) {
                                          return Relude_String.splitAsList("", param);
                                        }), partial_arg, param);
                          })(Relude_String.splitAsList("\n", string)))));
}

function nextKeys$prime(map, collectedKeys, _distances, _pointsNotVisited, _keys) {
  while(true) {
    var keys = _keys;
    var pointsNotVisited = _pointsNotVisited;
    var distances = _distances;
    var filterNotReachedKeysOrLockedDoors = Curry._1(PointOfInterestMap.filterNot, (function(keys){
        return function (p, param) {
          if (typeof p === "number") {
            return false;
          } else if (p.TAG) {
            return !contains(p._0, collectedKeys);
          } else {
            return Curry._2(Relude_StringMap.contains, p._0, keys);
          }
        }
        }(keys)));
    var closest = Curry._1($$Set.minimum, Curry._2($$Set.filter, (function(pointsNotVisited){
            return function (param) {
              return Curry._2(PointOfInterestSet.contains, param.point, pointsNotVisited);
            }
            }(pointsNotVisited)), distances));
    if (closest === undefined) {
      return keys;
    }
    var reachable = Relude_List.map((function(closest){
          return function (param) {
            return {
                    point: param[0],
                    distance: closest.distance + param[1] | 0
                  };
          }
          }(closest)))(Curry._1(PointOfInterestMap.toList, Curry._1(filterNotReachedKeysOrLockedDoors, Curry._3(PointOfInterestMap.getOrElse, closest.point, Curry._1(PointOfInterestMap.make, undefined), map))));
    var match = Relude_List.partition((function (pd) {
            var k = pd.point;
            if (typeof k === "number" || k.TAG) {
              return false;
            } else {
              return !contains(k._0, collectedKeys);
            }
          }), reachable);
    var closerNotToCollect = Relude_List.filter((function(distances){
        return function (param) {
          var distance = param.distance;
          var point = param.point;
          return Relude_Option.getOrElse(true, Relude_Option.map((function (param) {
                            return param.distance > distance;
                          }), Curry._1($$Set.maximum, Curry._2($$Set.filter, (function (param) {
                                    return Caml_obj.caml_equal(point, param.point);
                                  }), distances))));
        }
        }(distances)), match[1]);
    var nextKeys = Relude_List.foldLeft((function (acc, param) {
              return Curry._3(Relude_StringMap.set, param[0], param[1], acc);
            }), keys)(Relude_List.mapOption((function (param) {
                var k = param.point;
                if (typeof k === "number" || k.TAG) {
                  return ;
                } else {
                  return [
                          k._0,
                          param.distance
                        ];
                }
              }), match[0]));
    var nextDistances = Relude_List.foldLeft((function (acc, pwd) {
              var removed = Relude_Option.getOrElse(acc, Relude_Option.map((function (p) {
                          return Curry._2($$Set.remove, p, acc);
                        }), Curry._1($$Set.maximum, Curry._2($$Set.filter, (function (param) {
                                  return Caml_obj.caml_equal(param.point, pwd.point);
                                }), acc))));
              return Curry._2($$Set.add, pwd, removed);
            }), distances)(closerNotToCollect);
    var nextPointsNotVisited = Relude_List.foldLeft((function (acc, param) {
              return Curry._2(PointOfInterestSet.add, param.point, acc);
            }), Curry._2(PointOfInterestSet.remove, closest.point, pointsNotVisited))(closerNotToCollect);
    _keys = nextKeys;
    _pointsNotVisited = nextPointsNotVisited;
    _distances = nextDistances;
    continue ;
  };
}

function nextKeys(collectedKeys, current, map) {
  return Relude_List.sortBy((function (param, param$1) {
                return Curry._2(Relude_Int.Ord.compare, param[1], param$1[1]);
              }), Curry._1(Relude_StringMap.toList, nextKeys$prime(map, collectedKeys, Curry._1($$Set.fromList, {
                          hd: {
                            point: current,
                            distance: 0
                          },
                          tl: /* [] */0
                        }), Curry._1(PointOfInterestSet.fromList, {
                          hd: current,
                          tl: /* [] */0
                        }), Curry._1(Relude_StringMap.make, undefined))));
}

function numberOfKeys(map) {
  return Curry._3(PointOfInterestMap.foldLeft, (function (c, k, param) {
                if (typeof k === "number" || k.TAG) {
                  return c;
                } else {
                  return c + 1 | 0;
                }
              }), 0, map);
}

function collectAllKeys$prime(targetKeyCount, _ongoingStates, _bestDistances, nextKeys) {
  while(true) {
    var bestDistances = _bestDistances;
    var ongoingStates = _ongoingStates;
    var closest = Relude_Option.getOrThrow(Curry._1($$Set$1.minimum, ongoingStates));
    if (length(closest.collectedKeys) === targetKeyCount) {
      return closest.distance;
    }
    var statesWithoutClosest = Curry._2($$Set$1.remove, closest, ongoingStates);
    var collectedKeys = closest.collectedKeys;
    var distance = closest.distance;
    var keys = Curry._2(nextKeys, collectedKeys, closest.point);
    var newStates = Relude_List.map((function(distance,collectedKeys){
          return function (param) {
            var k = param[0];
            return {
                    point: {
                      TAG: /* Key */0,
                      _0: k
                    },
                    distance: distance + param[1] | 0,
                    collectedKeys: collectedKeys | sToT(k)
                  };
          }
          }(distance,collectedKeys)))(keys);
    var closerStates = Curry._2($$Set$1.filter, (function(bestDistances){
        return function (param) {
          var distance = param.distance;
          return Relude_Option.getOrElse(true, Relude_Option.map((function (d) {
                            return d > distance;
                          }), Curry._2($$Map.get, {
                              point: param.point,
                              collectedKeys: param.collectedKeys
                            }, bestDistances)));
        }
        }(bestDistances)), Curry._1($$Set$1.fromList, newStates));
    var newBestDistances = Curry._3($$Set$1.foldLeft, (function (acc, param) {
            return Curry._3($$Map.set, {
                        point: param.point,
                        collectedKeys: param.collectedKeys
                      }, param.distance, acc);
          }), bestDistances, closerStates);
    var states = Curry._2($$Set$1.union, statesWithoutClosest, closerStates);
    _bestDistances = newBestDistances;
    _ongoingStates = states;
    continue ;
  };
}

function collectAllKeys(map) {
  var targetKeyCount = numberOfKeys(map);
  var cache = {
    contents: Curry._1($$Map.make, undefined)
  };
  var nextKeysForMap = function (collectedKeys, current) {
    var key = {
      point: current,
      collectedKeys: collectedKeys
    };
    var v = Curry._2($$Map.get, key, cache.contents);
    if (v !== undefined) {
      return v;
    }
    var v$1 = nextKeys(collectedKeys, current, map);
    cache.contents = Curry._3($$Map.set, key, v$1, cache.contents);
    return v$1;
  };
  return collectAllKeys$prime(targetKeyCount, Curry._1($$Set$1.fromList, {
                  hd: {
                    point: /* Start */0,
                    distance: 0,
                    collectedKeys: 0
                  },
                  tl: /* [] */0
                }), Curry._1($$Map.fromList, {
                  hd: [
                    {
                      point: /* Start */0,
                      collectedKeys: 0
                    },
                    0
                  ],
                  tl: /* [] */0
                }), nextKeysForMap);
}

var Maze = {
  UnknownCell: UnknownCell,
  charToCell: charToCell,
  mapToGraph: mapToGraph,
  fromString: fromString,
  nextKeys$prime: nextKeys$prime,
  nextKeys: nextKeys,
  numberOfKeys: numberOfKeys,
  collectAllKeys$prime: collectAllKeys$prime,
  collectAllKeys: collectAllKeys
};

var input = InputLoader$Aoc19.loadDay(18);

StackSafeFuture$Aoc19.tap(function (param) {
        return Relude_Function.flipCompose((function (param) {
                      return Relude_Function.flipCompose(fromString, collectAllKeys, param);
                    }), (function (prim) {
                      console.log(prim);
                      
                    }), param);
      })(input);

var $great$great = Relude_Function.flipCompose;

exports.$great$great = $great$great;
exports.PointOfInterestOrd = PointOfInterestOrd;
exports.PointOfInterestMap = PointOfInterestMap;
exports.PointOfInterestSet = PointOfInterestSet;
exports.KeySet = KeySet;
exports.PointWithDistance = PointWithDistance;
exports.PointWithCollectedKeys = PointWithCollectedKeys;
exports.CollectionState = CollectionState;
exports.Maze = Maze;
exports.input = input;
/* PointOfInterestMap Not a pure module */
