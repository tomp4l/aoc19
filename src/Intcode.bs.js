// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Relude_List = require("relude/src/Relude_List.bs.js");
var Relude_Array = require("relude/src/Relude_Array.bs.js");
var Relude_Tuple = require("relude/src/Relude_Tuple.bs.js");
var Relude_Option = require("relude/src/Relude_Option.bs.js");
var Relude_String = require("relude/src/Relude_String.bs.js");
var Readline$Aoc19 = require("./lib/Readline.bs.js");
var Relude_Function = require("relude/src/Relude_Function.bs.js");
var StackSafeFuture$Aoc19 = require("./lib/StackSafeFuture.bs.js");

function position(a, tape) {
  return Relude_Option.map((function (prim) {
                return prim[0];
              }), Relude_Array.at(a[0], tape));
}

function immediate(a) {
  return Caml_option.some(a[0]);
}

function getVal(mode, a, tape) {
  switch (mode) {
    case "0" :
        return position(a, tape);
    case "1" :
        return Caml_option.some(a[0]);
    default:
      console.error("Unknown mode", mode);
      return ;
  }
}

function op3(tape, modes, op, a, b, c) {
  var modes$1 = Relude_Tuple.fromListAtLeast2(modes);
  return Relude_Option.isSome(Curry._2(Relude_Option.flatMap, (function (param) {
                    var l = getVal(param[0], a, tape);
                    var r = getVal(param[1], b, tape);
                    var c$1 = Relude_Array.at(c[0], tape);
                    var calculated = Curry._3(Relude_Option.map2, op, l, r);
                    return Curry._3(Relude_Option.map2, (function (v, state) {
                                  v[0] = state;
                                  return /* () */0;
                                }), c$1, calculated);
                  }), modes$1));
}

function args3(pointer, tape) {
  return Relude_Function.uncurry3(Relude_Option.tuple3, /* tuple */[
              Relude_Array.at(pointer + 1 | 0, tape),
              Relude_Array.at(pointer + 2 | 0, tape),
              Relude_Array.at(pointer + 3 | 0, tape)
            ]);
}

function args2(pointer, tape) {
  return Relude_Function.uncurry2(Relude_Option.tuple2, /* tuple */[
              Relude_Array.at(pointer + 1 | 0, tape),
              Relude_Array.at(pointer + 2 | 0, tape)
            ]);
}

function doOp3(tape, pointer, modes, op) {
  var args = args3(pointer, tape);
  Relude_Option.map((function (param) {
          return Relude_Function.uncurry3((function (param, param$1, param$2) {
                        return op3(tape, modes, op, param, param$1, param$2);
                      }), param);
        }), args);
  return StackSafeFuture$Aoc19.pure(pointer + 4 | 0);
}

function readInput(tape, pointer) {
  var readline = Readline$Aoc19.make(/* () */0);
  var input = Readline$Aoc19.question(readline, "input dear human\n");
  var cell = Relude_Option.map((function (prim) {
          return prim[0];
        }), Relude_Array.at(pointer + 1 | 0, tape));
  return StackSafeFuture$Aoc19.tap((function (param) {
                  readline.close();
                  return /* () */0;
                }))(StackSafeFuture$Aoc19.map((function (i) {
                    var partial_arg = pointer + 2 | 0;
                    return Relude_Option.map((function (param) {
                                  return Relude_Function.$$const(partial_arg, param);
                                }), Relude_Option.map((function (v) {
                                      v[0] = Caml_format.caml_int_of_string(i);
                                      return /* () */0;
                                    }), Curry._2(Relude_Option.flatMap, (function (c) {
                                          return Relude_Array.at(c, tape);
                                        }), cell)));
                  }), input));
}

function doOutput(tape, pointer) {
  var cell = Relude_Option.map((function (prim) {
          return prim[0];
        }), Relude_Array.at(pointer + 1 | 0, tape));
  var partial_arg = pointer + 2 | 0;
  return StackSafeFuture$Aoc19.pure(Relude_Option.map((function (param) {
                    return Relude_Function.$$const(partial_arg, param);
                  }), Relude_Option.map((function (v) {
                        console.log("Output: ", v[0]);
                        return /* () */0;
                      }), Curry._2(Relude_Option.flatMap, (function (c) {
                            return Relude_Array.at(c, tape);
                          }), cell))));
}

function jumpIf(tape, pointer, modes, nonZero) {
  var modes$1 = Relude_Tuple.fromListAtLeast2(modes);
  var args = args2(pointer, tape);
  return StackSafeFuture$Aoc19.pure(Curry._2(Relude_Option.flatMap, (function (param) {
                    var match = param[1];
                    var match$1 = param[0];
                    var a$prime = getVal(match[0], match$1[0], tape);
                    var b$prime = getVal(match[1], match$1[1], tape);
                    return Curry._3(Relude_Option.map2, (function (v$prime, p) {
                                  if (nonZero) {
                                    if (v$prime !== 0) {
                                      return p;
                                    } else {
                                      return pointer + 3 | 0;
                                    }
                                  } else if (v$prime !== 0) {
                                    return pointer + 3 | 0;
                                  } else {
                                    return p;
                                  }
                                }), a$prime, b$prime);
                  }), Curry._3(Relude_Option.map2, (function (a, b) {
                        return /* tuple */[
                                a,
                                b
                              ];
                      }), args, modes$1)));
}

function run(intcode) {
  var tape = Relude_Array.fromList(Relude_List.map((function (x) {
                return /* record */[/* contents */x];
              }))(intcode));
  var program = function (pointer) {
    var match = Relude_Array.at(pointer, tape);
    var $$continue;
    if (match !== undefined) {
      var op = String(match[0]);
      var padded = Relude_String.repeat(5, "0") + op;
      var split = Relude_List.reverse(Relude_String.splitList("", padded));
      var exit = 0;
      if (split) {
        switch (split[0]) {
          case "1" :
              var match$1 = split[1];
              if (match$1 && match$1[0] === "0") {
                $$continue = doOp3(tape, pointer, match$1[1], (function (prim, prim$1) {
                        return prim + prim$1 | 0;
                      }));
              } else {
                exit = 1;
              }
              break;
          case "2" :
              var match$2 = split[1];
              if (match$2 && match$2[0] === "0") {
                $$continue = doOp3(tape, pointer, match$2[1], Caml_int32.imul);
              } else {
                exit = 1;
              }
              break;
          case "3" :
              var match$3 = split[1];
              if (match$3 && match$3[0] === "0") {
                $$continue = readInput(tape, pointer);
              } else {
                exit = 1;
              }
              break;
          case "4" :
              var match$4 = split[1];
              if (match$4 && match$4[0] === "0") {
                $$continue = doOutput(tape, pointer);
              } else {
                exit = 1;
              }
              break;
          case "5" :
              var match$5 = split[1];
              if (match$5 && match$5[0] === "0") {
                $$continue = jumpIf(tape, pointer, match$5[1], true);
              } else {
                exit = 1;
              }
              break;
          case "6" :
              var match$6 = split[1];
              if (match$6 && match$6[0] === "0") {
                $$continue = jumpIf(tape, pointer, match$6[1], false);
              } else {
                exit = 1;
              }
              break;
          case "7" :
              var match$7 = split[1];
              if (match$7 && match$7[0] === "0") {
                $$continue = doOp3(tape, pointer, match$7[1], (function (a, b) {
                        if (a < b) {
                          return 1;
                        } else {
                          return 0;
                        }
                      }));
              } else {
                exit = 1;
              }
              break;
          case "8" :
              var match$8 = split[1];
              if (match$8 && match$8[0] === "0") {
                $$continue = doOp3(tape, pointer, match$8[1], (function (a, b) {
                        if (a === b) {
                          return 1;
                        } else {
                          return 0;
                        }
                      }));
              } else {
                exit = 1;
              }
              break;
          case "9" :
              var match$9 = split[1];
              if (match$9 && match$9[0] === "9") {
                $$continue = StackSafeFuture$Aoc19.pure(undefined);
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        console.error("Unknown op", op);
        $$continue = StackSafeFuture$Aoc19.pure(undefined);
      }
      
    } else {
      console.error("Invalid pointer", pointer);
      $$continue = StackSafeFuture$Aoc19.pure(undefined);
    }
    return Curry._2(StackSafeFuture$Aoc19.flatMap, (function ($$continue) {
                  if ($$continue !== undefined) {
                    return program($$continue);
                  } else {
                    return StackSafeFuture$Aoc19.pure(/* () */0);
                  }
                }), $$continue);
  };
  var done_ = program(0);
  return StackSafeFuture$Aoc19.map((function (param) {
                return Relude_Option.map((function (prim) {
                              return prim[0];
                            }), Relude_Array.head(tape));
              }), done_);
}

exports.position = position;
exports.immediate = immediate;
exports.getVal = getVal;
exports.op3 = op3;
exports.args3 = args3;
exports.args2 = args2;
exports.doOp3 = doOp3;
exports.readInput = readInput;
exports.doOutput = doOutput;
exports.jumpIf = jumpIf;
exports.run = run;
/* Relude_List Not a pure module */
